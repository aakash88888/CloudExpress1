{
  "version": 3,
  "sources": ["../src/types.ts", "../src/utils.ts", "../src/snapshot.ts", "../src/css.ts", "../src/rebuild.ts"],
  "sourcesContent": ["export enum NodeType {\n  Document,\n  DocumentType,\n  Element,\n  Text,\n  CDATA,\n  Comment,\n}\n\nexport type documentNode = {\n  type: NodeType.Document;\n  childNodes: serializedNodeWithId[];\n  compatMode?: string;\n};\n\nexport type documentTypeNode = {\n  type: NodeType.DocumentType;\n  name: string;\n  publicId: string;\n  systemId: string;\n};\n\nexport type attributes = {\n  [key: string]: string | number | true | null;\n};\nexport type legacyAttributes = {\n  /**\n   * @deprecated old bug in rrweb was causing these to always be set\n   * @see https://github.com/rrweb-io/rrweb/pull/651\n   */\n  selected: false;\n};\n\nexport type elementNode = {\n  type: NodeType.Element;\n  tagName: string;\n  attributes: attributes;\n  childNodes: serializedNodeWithId[];\n  isSVG?: true;\n  needBlock?: boolean;\n  // This is a custom element or not.\n  isCustom?: true;\n};\n\nexport type textNode = {\n  type: NodeType.Text;\n  textContent: string;\n  isStyle?: true;\n};\n\nexport type cdataNode = {\n  type: NodeType.CDATA;\n  textContent: '';\n};\n\nexport type commentNode = {\n  type: NodeType.Comment;\n  textContent: string;\n};\n\nexport type serializedNode = (\n  | documentNode\n  | documentTypeNode\n  | elementNode\n  | textNode\n  | cdataNode\n  | commentNode\n) & {\n  rootId?: number;\n  isShadowHost?: boolean;\n  isShadow?: boolean;\n};\n\nexport type serializedNodeWithId = serializedNode & { id: number };\n\nexport type serializedElementNodeWithId = Extract<\n  serializedNodeWithId,\n  Record<'type', NodeType.Element>\n>;\n\nexport type tagMap = {\n  [key: string]: string;\n};\n\nexport type mediaAttributes = {\n  rr_mediaState: 'played' | 'paused';\n  rr_mediaCurrentTime: number;\n  /**\n   * for backwards compatibility this is optional but should always be set\n   */\n  rr_mediaPlaybackRate?: number;\n  /**\n   * for backwards compatibility this is optional but should always be set\n   */\n  rr_mediaMuted?: boolean;\n  /**\n   * for backwards compatibility this is optional but should always be set\n   */\n  rr_mediaLoop?: boolean;\n  /**\n   * for backwards compatibility this is optional but should always be set\n   */\n  rr_mediaVolume?: number;\n};\n\n// @deprecated\nexport interface INode extends Node {\n  __sn: serializedNodeWithId;\n}\n\nexport interface ICanvas extends HTMLCanvasElement {\n  __context: string;\n}\n\nexport interface IMirror<TNode> {\n  getId(n: TNode | undefined | null): number;\n\n  getNode(id: number): TNode | null;\n\n  getIds(): number[];\n\n  getMeta(n: TNode): serializedNodeWithId | null;\n\n  removeNodeFromMap(n: TNode): void;\n\n  has(id: number): boolean;\n\n  hasNode(node: TNode): boolean;\n\n  add(n: TNode, meta: serializedNodeWithId): void;\n\n  replace(id: number, n: TNode): void;\n\n  reset(): void;\n}\n\nexport type idNodeMap = Map<number, Node>;\n\nexport type nodeMetaMap = WeakMap<Node, serializedNodeWithId>;\n\nexport type MaskInputOptions = Partial<{\n  color: boolean;\n  date: boolean;\n  'datetime-local': boolean;\n  email: boolean;\n  month: boolean;\n  number: boolean;\n  range: boolean;\n  search: boolean;\n  tel: boolean;\n  text: boolean;\n  time: boolean;\n  url: boolean;\n  week: boolean;\n  // unify textarea and select element with text input\n  textarea: boolean;\n  select: boolean;\n  password: boolean;\n}>;\n\nexport type SlimDOMOptions = Partial<{\n  script: boolean;\n  comment: boolean;\n  headFavicon: boolean;\n  headWhitespace: boolean;\n  headMetaDescKeywords: boolean;\n  headMetaSocial: boolean;\n  headMetaRobots: boolean;\n  headMetaHttpEquiv: boolean;\n  headMetaAuthorship: boolean;\n  headMetaVerification: boolean;\n  /**\n   * blocks title tag 'animations' which can generate a lot of mutations that aren't usually displayed in replayers\n   **/\n  headTitleMutations: boolean;\n}>;\n\nexport type DataURLOptions = Partial<{\n  type: string;\n  quality: number;\n}>;\n\nexport type MaskTextFn = (text: string, element: HTMLElement | null) => string;\nexport type MaskInputFn = (text: string, element: HTMLElement) => string;\n\nexport type KeepIframeSrcFn = (src: string) => boolean;\n\nexport type BuildCache = {\n  stylesWithHoverClass: Map<string, string>;\n};\n", "import type {\n  idNodeMap,\n  MaskInputFn,\n  MaskInputOptions,\n  nodeMetaMap,\n  IMirror,\n  serializedNodeWithId,\n  serializedNode,\n  documentNode,\n  documentTypeNode,\n  textNode,\n  elementNode,\n} from './types';\nimport { NodeType } from './types';\n\nexport function isElement(n: Node): n is Element {\n  return n.nodeType === n.ELEMENT_NODE;\n}\n\nexport function isShadowRoot(n: Node): n is ShadowRoot {\n  const host: Element | null = (n as ShadowRoot)?.host;\n  return Boolean(host?.shadowRoot === n);\n}\n\n/**\n * To fix the issue https://github.com/rrweb-io/rrweb/issues/933.\n * Some websites use polyfilled shadow dom and this function is used to detect this situation.\n */\nexport function isNativeShadowDom(shadowRoot: ShadowRoot): boolean {\n  return Object.prototype.toString.call(shadowRoot) === '[object ShadowRoot]';\n}\n\n/**\n * Browsers sometimes destructively modify the css rules they receive.\n * This function tries to rectify the modifications the browser made to make it more cross platform compatible.\n * @param cssText - output of `CSSStyleRule.cssText`\n * @returns `cssText` with browser inconsistencies fixed.\n */\nfunction fixBrowserCompatibilityIssuesInCSS(cssText: string): string {\n  /**\n   * Chrome outputs `-webkit-background-clip` as `background-clip` in `CSSStyleRule.cssText`.\n   * But then Chrome ignores `background-clip` as css input.\n   * Re-introduce `-webkit-background-clip` to fix this issue.\n   */\n  if (\n    cssText.includes(' background-clip: text;') &&\n    !cssText.includes(' -webkit-background-clip: text;')\n  ) {\n    cssText = cssText.replace(\n      /\\sbackground-clip:\\s*text;/g,\n      ' -webkit-background-clip: text; background-clip: text;',\n    );\n  }\n  return cssText;\n}\n\n// Remove this declaration once typescript has added `CSSImportRule.supportsText` to the lib.\ndeclare interface CSSImportRule extends CSSRule {\n  readonly href: string;\n  readonly layerName: string | null;\n  readonly media: MediaList;\n  readonly styleSheet: CSSStyleSheet;\n  /**\n   * experimental API, currently only supported in firefox\n   * https://developer.mozilla.org/en-US/docs/Web/API/CSSImportRule/supportsText\n   */\n  readonly supportsText?: string | null;\n}\n\n/**\n * Browsers sometimes incorrectly escape `@import` on `.cssText` statements.\n * This function tries to correct the escaping.\n * more info: https://bugs.chromium.org/p/chromium/issues/detail?id=1472259\n * @param cssImportRule\n * @returns `cssText` with browser inconsistencies fixed, or null if not applicable.\n */\nexport function escapeImportStatement(rule: CSSImportRule): string {\n  const { cssText } = rule;\n  if (cssText.split('\"').length < 3) return cssText;\n\n  const statement = ['@import', `url(${JSON.stringify(rule.href)})`];\n  if (rule.layerName === '') {\n    statement.push(`layer`);\n  } else if (rule.layerName) {\n    statement.push(`layer(${rule.layerName})`);\n  }\n  if (rule.supportsText) {\n    statement.push(`supports(${rule.supportsText})`);\n  }\n  if (rule.media.length) {\n    statement.push(rule.media.mediaText);\n  }\n  return statement.join(' ') + ';';\n}\n\nexport function stringifyStylesheet(s: CSSStyleSheet): string | null {\n  try {\n    const rules = s.rules || s.cssRules;\n    return rules\n      ? fixBrowserCompatibilityIssuesInCSS(\n          Array.from(rules, stringifyRule).join(''),\n        )\n      : null;\n  } catch (error) {\n    return null;\n  }\n}\n\nexport function stringifyRule(rule: CSSRule): string {\n  let importStringified;\n  if (isCSSImportRule(rule)) {\n    try {\n      importStringified =\n        // for same-origin stylesheets,\n        // we can access the imported stylesheet rules directly\n        stringifyStylesheet(rule.styleSheet) ||\n        // work around browser issues with the raw string `@import url(...)` statement\n        escapeImportStatement(rule);\n    } catch (error) {\n      // ignore\n    }\n  } else if (isCSSStyleRule(rule) && rule.selectorText.includes(':')) {\n    // Safari does not escape selectors with : properly\n    // see https://bugs.webkit.org/show_bug.cgi?id=184604\n    return fixSafariColons(rule.cssText);\n  }\n\n  return importStringified || rule.cssText;\n}\n\nexport function fixSafariColons(cssStringified: string): string {\n  // Replace e.g. [aa:bb] with [aa\\\\:bb]\n  const regex = /(\\[(?:[\\w-]+)[^\\\\])(:(?:[\\w-]+)\\])/gm;\n  return cssStringified.replace(regex, '$1\\\\$2');\n}\n\nexport function isCSSImportRule(rule: CSSRule): rule is CSSImportRule {\n  return 'styleSheet' in rule;\n}\n\nexport function isCSSStyleRule(rule: CSSRule): rule is CSSStyleRule {\n  return 'selectorText' in rule;\n}\n\nexport class Mirror implements IMirror<Node> {\n  private idNodeMap: idNodeMap = new Map();\n  private nodeMetaMap: nodeMetaMap = new WeakMap();\n\n  getId(n: Node | undefined | null): number {\n    if (!n) return -1;\n\n    const id = this.getMeta(n)?.id;\n\n    // if n is not a serialized Node, use -1 as its id.\n    return id ?? -1;\n  }\n\n  getNode(id: number): Node | null {\n    return this.idNodeMap.get(id) || null;\n  }\n\n  getIds(): number[] {\n    return Array.from(this.idNodeMap.keys());\n  }\n\n  getMeta(n: Node): serializedNodeWithId | null {\n    return this.nodeMetaMap.get(n) || null;\n  }\n\n  // removes the node from idNodeMap\n  // doesn't remove the node from nodeMetaMap\n  removeNodeFromMap(n: Node) {\n    const id = this.getId(n);\n    this.idNodeMap.delete(id);\n\n    if (n.childNodes) {\n      n.childNodes.forEach((childNode) =>\n        this.removeNodeFromMap(childNode as unknown as Node),\n      );\n    }\n  }\n  has(id: number): boolean {\n    return this.idNodeMap.has(id);\n  }\n\n  hasNode(node: Node): boolean {\n    return this.nodeMetaMap.has(node);\n  }\n\n  add(n: Node, meta: serializedNodeWithId) {\n    const id = meta.id;\n    this.idNodeMap.set(id, n);\n    this.nodeMetaMap.set(n, meta);\n  }\n\n  replace(id: number, n: Node) {\n    const oldNode = this.getNode(id);\n    if (oldNode) {\n      const meta = this.nodeMetaMap.get(oldNode);\n      if (meta) this.nodeMetaMap.set(n, meta);\n    }\n    this.idNodeMap.set(id, n);\n  }\n\n  reset() {\n    this.idNodeMap = new Map();\n    this.nodeMetaMap = new WeakMap();\n  }\n}\n\nexport function createMirror(): Mirror {\n  return new Mirror();\n}\n\nexport function maskInputValue({\n  element,\n  maskInputOptions,\n  tagName,\n  type,\n  value,\n  maskInputFn,\n}: {\n  element: HTMLElement;\n  maskInputOptions: MaskInputOptions;\n  tagName: string;\n  type: string | null;\n  value: string | null;\n  maskInputFn?: MaskInputFn;\n}): string {\n  let text = value || '';\n  const actualType = type && toLowerCase(type);\n\n  if (\n    maskInputOptions[tagName.toLowerCase() as keyof MaskInputOptions] ||\n    (actualType && maskInputOptions[actualType as keyof MaskInputOptions])\n  ) {\n    if (maskInputFn) {\n      text = maskInputFn(text, element);\n    } else {\n      text = '*'.repeat(text.length);\n    }\n  }\n  return text;\n}\n\nexport function toLowerCase<T extends string>(str: T): Lowercase<T> {\n  return str.toLowerCase() as unknown as Lowercase<T>;\n}\n\nconst ORIGINAL_ATTRIBUTE_NAME = '__rrweb_original__';\ntype PatchedGetImageData = {\n  [ORIGINAL_ATTRIBUTE_NAME]: CanvasImageData['getImageData'];\n} & CanvasImageData['getImageData'];\n\nexport function is2DCanvasBlank(canvas: HTMLCanvasElement): boolean {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) return true;\n\n  const chunkSize = 50;\n\n  // get chunks of the canvas and check if it is blank\n  for (let x = 0; x < canvas.width; x += chunkSize) {\n    for (let y = 0; y < canvas.height; y += chunkSize) {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const getImageData = ctx.getImageData as PatchedGetImageData;\n      const originalGetImageData =\n        ORIGINAL_ATTRIBUTE_NAME in getImageData\n          ? getImageData[ORIGINAL_ATTRIBUTE_NAME]\n          : getImageData;\n      // by getting the canvas in chunks we avoid an expensive\n      // `getImageData` call that retrieves everything\n      // even if we can already tell from the first chunk(s) that\n      // the canvas isn't blank\n      const pixelBuffer = new Uint32Array(\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access\n        originalGetImageData.call(\n          ctx,\n          x,\n          y,\n          Math.min(chunkSize, canvas.width - x),\n          Math.min(chunkSize, canvas.height - y),\n        ).data.buffer,\n      );\n      if (pixelBuffer.some((pixel) => pixel !== 0)) return false;\n    }\n  }\n  return true;\n}\n\nexport function isNodeMetaEqual(a: serializedNode, b: serializedNode): boolean {\n  if (!a || !b || a.type !== b.type) return false;\n  if (a.type === NodeType.Document)\n    return a.compatMode === (b as documentNode).compatMode;\n  else if (a.type === NodeType.DocumentType)\n    return (\n      a.name === (b as documentTypeNode).name &&\n      a.publicId === (b as documentTypeNode).publicId &&\n      a.systemId === (b as documentTypeNode).systemId\n    );\n  else if (\n    a.type === NodeType.Comment ||\n    a.type === NodeType.Text ||\n    a.type === NodeType.CDATA\n  )\n    return a.textContent === (b as textNode).textContent;\n  else if (a.type === NodeType.Element)\n    return (\n      a.tagName === (b as elementNode).tagName &&\n      JSON.stringify(a.attributes) ===\n        JSON.stringify((b as elementNode).attributes) &&\n      a.isSVG === (b as elementNode).isSVG &&\n      a.needBlock === (b as elementNode).needBlock\n    );\n  return false;\n}\n\n/**\n * Get the type of an input element.\n * This takes care of the case where a password input is changed to a text input.\n * In this case, we continue to consider this of type password, in order to avoid leaking sensitive data\n * where passwords should be masked.\n */\nexport function getInputType(element: HTMLElement): Lowercase<string> | null {\n  // when omitting the type of input element(e.g. <input />), the type is treated as text\n  const type = (element as HTMLInputElement).type;\n\n  return element.hasAttribute('data-rr-is-password')\n    ? 'password'\n    : type\n    ? // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n      toLowerCase(type)\n    : null;\n}\n\n/**\n * Extracts the file extension from an a path, considering search parameters and fragments.\n * @param path - Path to file\n * @param baseURL - [optional] Base URL of the page, used to resolve relative paths. Defaults to current page URL.\n */\nexport function extractFileExtension(\n  path: string,\n  baseURL?: string,\n): string | null {\n  let url;\n  try {\n    url = new URL(path, baseURL ?? window.location.href);\n  } catch (err) {\n    return null;\n  }\n  const regex = /\\.([0-9a-z]+)(?:$)/i;\n  const match = url.pathname.match(regex);\n  return match?.[1] ?? null;\n}\n", "import {\n  type serializedNode,\n  type serializedNodeWithId,\n  NodeType,\n  type attributes,\n  type MaskInputOptions,\n  type SlimDOMOptions,\n  type DataURLOptions,\n  type MaskTextFn,\n  type MaskInputFn,\n  type KeepIframeSrcFn,\n  type ICanvas,\n  type elementNode,\n  type serializedElementNodeWithId,\n  type mediaAttributes,\n} from './types';\nimport {\n  Mirror,\n  is2DCanvasBlank,\n  isElement,\n  isShadowRoot,\n  maskInputValue,\n  isNativeShadowDom,\n  stringifyStylesheet,\n  getInputType,\n  toLowerCase,\n  extractFileExtension,\n} from './utils';\n\nlet _id = 1;\nconst tagNameRegex = new RegExp('[^a-z0-9-_:]');\n\nexport const IGNORED_NODE = -2;\n\nexport function genId(): number {\n  return _id++;\n}\n\nfunction getValidTagName(element: HTMLElement): Lowercase<string> {\n  if (element instanceof HTMLFormElement) {\n    return 'form';\n  }\n\n  const processedTagName = toLowerCase(element.tagName);\n\n  if (tagNameRegex.test(processedTagName)) {\n    // if the tag name is odd and we cannot extract\n    // anything from the string, then we return a\n    // generic div\n    return 'div';\n  }\n\n  return processedTagName;\n}\n\nfunction extractOrigin(url: string): string {\n  let origin = '';\n  if (url.indexOf('//') > -1) {\n    origin = url.split('/').slice(0, 3).join('/');\n  } else {\n    origin = url.split('/')[0];\n  }\n  origin = origin.split('?')[0];\n  return origin;\n}\n\nlet canvasService: HTMLCanvasElement | null;\nlet canvasCtx: CanvasRenderingContext2D | null;\n\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\nconst URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\\/\\//i;\nconst URL_WWW_MATCH = /^www\\..*/i;\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\nexport function absoluteToStylesheet(\n  cssText: string | null,\n  href: string,\n): string {\n  return (cssText || '').replace(\n    URL_IN_CSS_REF,\n    (\n      origin: string,\n      quote1: string,\n      path1: string,\n      quote2: string,\n      path2: string,\n      path3: string,\n    ) => {\n      const filePath = path1 || path2 || path3;\n      const maybeQuote = quote1 || quote2 || '';\n      if (!filePath) {\n        return origin;\n      }\n      if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (DATA_URI.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (filePath[0] === '/') {\n        return `url(${maybeQuote}${\n          extractOrigin(href) + filePath\n        }${maybeQuote})`;\n      }\n      const stack = href.split('/');\n      const parts = filePath.split('/');\n      stack.pop();\n      for (const part of parts) {\n        if (part === '.') {\n          continue;\n        } else if (part === '..') {\n          stack.pop();\n        } else {\n          stack.push(part);\n        }\n      }\n      return `url(${maybeQuote}${stack.join('/')}${maybeQuote})`;\n    },\n  );\n}\n\n// eslint-disable-next-line no-control-regex\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/; // Don't use \\s, to avoid matching non-breaking space\n// eslint-disable-next-line no-control-regex\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\nfunction getAbsoluteSrcsetString(doc: Document, attributeValue: string) {\n  /*\n    run absoluteToDoc over every url in the srcset\n\n    this is adapted from https://github.com/albell/parse-srcset/\n    without the parsing of the descriptors (we return these as-is)\n    parce-srcset is in turn based on\n    https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-srcset-attribute\n  */\n  if (attributeValue.trim() === '') {\n    return attributeValue;\n  }\n\n  let pos = 0;\n\n  function collectCharacters(regEx: RegExp) {\n    let chars: string;\n    const match = regEx.exec(attributeValue.substring(pos));\n    if (match) {\n      chars = match[0];\n      pos += chars.length;\n      return chars;\n    }\n    return '';\n  }\n\n  const output = [];\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    collectCharacters(SRCSET_COMMAS_OR_SPACES);\n    if (pos >= attributeValue.length) {\n      break;\n    }\n    // don't split on commas within urls\n    let url = collectCharacters(SRCSET_NOT_SPACES);\n    if (url.slice(-1) === ',') {\n      // aside: according to spec more than one comma at the end is a parse error, but we ignore that\n      url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n      // the trailing comma splits the srcset, so the interpretion is that\n      // another url will follow, and the descriptor is empty\n      output.push(url);\n    } else {\n      let descriptorsStr = '';\n      url = absoluteToDoc(doc, url);\n      let inParens = false;\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        const c = attributeValue.charAt(pos);\n        if (c === '') {\n          output.push((url + descriptorsStr).trim());\n          break;\n        } else if (!inParens) {\n          if (c === ',') {\n            pos += 1;\n            output.push((url + descriptorsStr).trim());\n            break; // parse the next url\n          } else if (c === '(') {\n            inParens = true;\n          }\n        } else {\n          // in parenthesis; ignore commas\n          // (parenthesis may be supported by future additions to spec)\n          if (c === ')') {\n            inParens = false;\n          }\n        }\n        descriptorsStr += c;\n        pos += 1;\n      }\n    }\n  }\n  return output.join(', ');\n}\n\nconst cachedDocument = new WeakMap<Document, HTMLAnchorElement>();\n\nexport function absoluteToDoc(doc: Document, attributeValue: string): string {\n  if (!attributeValue || attributeValue.trim() === '') {\n    return attributeValue;\n  }\n\n  return getHref(doc, attributeValue);\n}\n\nfunction isSVGElement(el: Element): boolean {\n  return Boolean(el.tagName === 'svg' || (el as SVGElement).ownerSVGElement);\n}\n\nfunction getHref(doc: Document, customHref?: string) {\n  let a = cachedDocument.get(doc);\n  if (!a) {\n    a = doc.createElement('a');\n    cachedDocument.set(doc, a);\n  }\n  if (!customHref) {\n    customHref = '';\n  } else if (customHref.startsWith('blob:') || customHref.startsWith('data:')) {\n    return customHref;\n  }\n  // note: using `new URL` is slower. See #1434 or https://jsbench.me/uqlud17rxo/1\n  a.setAttribute('href', customHref);\n  return a.href;\n}\n\nexport function transformAttribute(\n  doc: Document,\n  tagName: Lowercase<string>,\n  name: Lowercase<string>,\n  value: string | null,\n): string | null {\n  if (!value) {\n    return value;\n  }\n\n  // relative path in attribute\n  if (\n    name === 'src' ||\n    (name === 'href' && !(tagName === 'use' && value[0] === '#'))\n  ) {\n    // href starts with a # is an id pointer for svg\n    return absoluteToDoc(doc, value);\n  } else if (name === 'xlink:href' && value[0] !== '#') {\n    // xlink:href starts with # is an id pointer\n    return absoluteToDoc(doc, value);\n  } else if (\n    name === 'background' &&\n    (tagName === 'table' || tagName === 'td' || tagName === 'th')\n  ) {\n    return absoluteToDoc(doc, value);\n  } else if (name === 'srcset') {\n    return getAbsoluteSrcsetString(doc, value);\n  } else if (name === 'style') {\n    return absoluteToStylesheet(value, getHref(doc));\n  } else if (tagName === 'object' && name === 'data') {\n    return absoluteToDoc(doc, value);\n  }\n\n  return value;\n}\n\nexport function ignoreAttribute(\n  tagName: string,\n  name: string,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _value: unknown,\n): boolean {\n  return (tagName === 'video' || tagName === 'audio') && name === 'autoplay';\n}\n\nexport function _isBlockedElement(\n  element: HTMLElement,\n  blockClass: string | RegExp,\n  blockSelector: string | null,\n): boolean {\n  try {\n    if (typeof blockClass === 'string') {\n      if (element.classList.contains(blockClass)) {\n        return true;\n      }\n    } else {\n      for (let eIndex = element.classList.length; eIndex--; ) {\n        const className = element.classList[eIndex];\n        if (blockClass.test(className)) {\n          return true;\n        }\n      }\n    }\n    if (blockSelector) {\n      return element.matches(blockSelector);\n    }\n  } catch (e) {\n    //\n  }\n\n  return false;\n}\n\nexport function classMatchesRegex(\n  node: Node | null,\n  regex: RegExp,\n  checkAncestors: boolean,\n): boolean {\n  if (!node) return false;\n  if (node.nodeType !== node.ELEMENT_NODE) {\n    if (!checkAncestors) return false;\n    return classMatchesRegex(node.parentNode, regex, checkAncestors);\n  }\n\n  for (let eIndex = (node as HTMLElement).classList.length; eIndex--; ) {\n    const className = (node as HTMLElement).classList[eIndex];\n    if (regex.test(className)) {\n      return true;\n    }\n  }\n  if (!checkAncestors) return false;\n  return classMatchesRegex(node.parentNode, regex, checkAncestors);\n}\n\nexport function needMaskingText(\n  node: Node,\n  maskTextClass: string | RegExp,\n  maskTextSelector: string | null,\n  checkAncestors: boolean,\n): boolean {\n  let el: Element;\n  if (isElement(node)) {\n    el = node;\n    if (!el.childNodes.length) {\n      // optimisation: we can avoid any of the below checks on leaf elements\n      // as masking is applied to child text nodes only\n      return false;\n    }\n  } else if (node.parentElement === null) {\n    // should warn? maybe a text node isn't attached to a parent node yet?\n    return false;\n  } else {\n    el = node.parentElement;\n  }\n  try {\n    if (typeof maskTextClass === 'string') {\n      if (checkAncestors) {\n        if (el.closest(`.${maskTextClass}`)) return true;\n      } else {\n        if (el.classList.contains(maskTextClass)) return true;\n      }\n    } else {\n      if (classMatchesRegex(el, maskTextClass, checkAncestors)) return true;\n    }\n    if (maskTextSelector) {\n      if (checkAncestors) {\n        if (el.closest(maskTextSelector)) return true;\n      } else {\n        if (el.matches(maskTextSelector)) return true;\n      }\n    }\n  } catch (e) {\n    //\n  }\n  return false;\n}\n\n// https://stackoverflow.com/a/36155560\nfunction onceIframeLoaded(\n  iframeEl: HTMLIFrameElement,\n  listener: () => unknown,\n  iframeLoadTimeout: number,\n) {\n  const win = iframeEl.contentWindow;\n  if (!win) {\n    return;\n  }\n  // document is loading\n  let fired = false;\n\n  let readyState: DocumentReadyState;\n  try {\n    readyState = win.document.readyState;\n  } catch (error) {\n    return;\n  }\n  if (readyState !== 'complete') {\n    const timer = setTimeout(() => {\n      if (!fired) {\n        listener();\n        fired = true;\n      }\n    }, iframeLoadTimeout);\n    iframeEl.addEventListener('load', () => {\n      clearTimeout(timer);\n      fired = true;\n      listener();\n    });\n    return;\n  }\n  // check blank frame for Chrome\n  const blankUrl = 'about:blank';\n  if (\n    win.location.href !== blankUrl ||\n    iframeEl.src === blankUrl ||\n    iframeEl.src === ''\n  ) {\n    // iframe was already loaded, make sure we wait to trigger the listener\n    // till _after_ the mutation that found this iframe has had time to process\n    setTimeout(listener, 0);\n\n    return iframeEl.addEventListener('load', listener); // keep listing for future loads\n  }\n  // use default listener\n  iframeEl.addEventListener('load', listener);\n}\n\nfunction onceStylesheetLoaded(\n  link: HTMLLinkElement,\n  listener: () => unknown,\n  styleSheetLoadTimeout: number,\n) {\n  let fired = false;\n  let styleSheetLoaded: StyleSheet | null;\n  try {\n    styleSheetLoaded = link.sheet;\n  } catch (error) {\n    return;\n  }\n\n  if (styleSheetLoaded) return;\n\n  const timer = setTimeout(() => {\n    if (!fired) {\n      listener();\n      fired = true;\n    }\n  }, styleSheetLoadTimeout);\n\n  link.addEventListener('load', () => {\n    clearTimeout(timer);\n    fired = true;\n    listener();\n  });\n}\n\nfunction serializeNode(\n  n: Node,\n  options: {\n    doc: Document;\n    mirror: Mirror;\n    blockClass: string | RegExp;\n    blockSelector: string | null;\n    needsMask: boolean;\n    inlineStylesheet: boolean;\n    maskInputOptions: MaskInputOptions;\n    maskTextFn: MaskTextFn | undefined;\n    maskInputFn: MaskInputFn | undefined;\n    dataURLOptions?: DataURLOptions;\n    inlineImages: boolean;\n    recordCanvas: boolean;\n    keepIframeSrcFn: KeepIframeSrcFn;\n    /**\n     * `newlyAddedElement: true` skips scrollTop and scrollLeft check\n     */\n    newlyAddedElement?: boolean;\n  },\n): serializedNode | false {\n  const {\n    doc,\n    mirror,\n    blockClass,\n    blockSelector,\n    needsMask,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions = {},\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement = false,\n  } = options;\n  // Only record root id when document object is not the base document\n  const rootId = getRootId(doc, mirror);\n  switch (n.nodeType) {\n    case n.DOCUMENT_NODE:\n      if ((n as Document).compatMode !== 'CSS1Compat') {\n        return {\n          type: NodeType.Document,\n          childNodes: [],\n          compatMode: (n as Document).compatMode, // probably \"BackCompat\"\n        };\n      } else {\n        return {\n          type: NodeType.Document,\n          childNodes: [],\n        };\n      }\n    case n.DOCUMENT_TYPE_NODE:\n      return {\n        type: NodeType.DocumentType,\n        name: (n as DocumentType).name,\n        publicId: (n as DocumentType).publicId,\n        systemId: (n as DocumentType).systemId,\n        rootId,\n      };\n    case n.ELEMENT_NODE:\n      return serializeElementNode(n as HTMLElement, {\n        doc,\n        blockClass,\n        blockSelector,\n        inlineStylesheet,\n        maskInputOptions,\n        maskInputFn,\n        dataURLOptions,\n        inlineImages,\n        recordCanvas,\n        keepIframeSrcFn,\n        newlyAddedElement,\n        rootId,\n      });\n    case n.TEXT_NODE:\n      return serializeTextNode(n as Text, {\n        doc,\n        needsMask,\n        maskTextFn,\n        rootId,\n      });\n    case n.CDATA_SECTION_NODE:\n      return {\n        type: NodeType.CDATA,\n        textContent: '',\n        rootId,\n      };\n    case n.COMMENT_NODE:\n      return {\n        type: NodeType.Comment,\n        textContent: (n as Comment).textContent || '',\n        rootId,\n      };\n    default:\n      return false;\n  }\n}\n\nfunction getRootId(doc: Document, mirror: Mirror): number | undefined {\n  if (!mirror.hasNode(doc)) return undefined;\n  const docId = mirror.getId(doc);\n  return docId === 1 ? undefined : docId;\n}\n\nfunction serializeTextNode(\n  n: Text,\n  options: {\n    doc: Document;\n    needsMask: boolean;\n    maskTextFn: MaskTextFn | undefined;\n    rootId: number | undefined;\n  },\n): serializedNode {\n  const { needsMask, maskTextFn, rootId } = options;\n  // The parent node may not be a html element which has a tagName attribute.\n  // So just let it be undefined which is ok in this use case.\n  const parentTagName = n.parentNode && (n.parentNode as HTMLElement).tagName;\n  let textContent = n.textContent;\n  const isStyle = parentTagName === 'STYLE' ? true : undefined;\n  const isScript = parentTagName === 'SCRIPT' ? true : undefined;\n  if (isStyle && textContent) {\n    try {\n      // try to read style sheet\n      if (n.nextSibling || n.previousSibling) {\n        // This is not the only child of the stylesheet.\n        // We can't read all of the sheet's .cssRules and expect them\n        // to _only_ include the current rule(s) added by the text node.\n        // So we'll be conservative and keep textContent as-is.\n      } else if ((n.parentNode as HTMLStyleElement).sheet?.cssRules) {\n        textContent = stringifyStylesheet(\n          (n.parentNode as HTMLStyleElement).sheet!,\n        );\n      }\n    } catch (err) {\n      console.warn(\n        `Cannot get CSS styles from text's parentNode. Error: ${err as string}`,\n        n,\n      );\n    }\n    textContent = absoluteToStylesheet(textContent, getHref(options.doc));\n  }\n  if (isScript) {\n    textContent = 'SCRIPT_PLACEHOLDER';\n  }\n  if (!isStyle && !isScript && textContent && needsMask) {\n    textContent = maskTextFn\n      ? maskTextFn(textContent, n.parentElement)\n      : textContent.replace(/[\\S]/g, '*');\n  }\n\n  return {\n    type: NodeType.Text,\n    textContent: textContent || '',\n    isStyle,\n    rootId,\n  };\n}\n\nfunction serializeElementNode(\n  n: HTMLElement,\n  options: {\n    doc: Document;\n    blockClass: string | RegExp;\n    blockSelector: string | null;\n    inlineStylesheet: boolean;\n    maskInputOptions: MaskInputOptions;\n    maskInputFn: MaskInputFn | undefined;\n    dataURLOptions?: DataURLOptions;\n    inlineImages: boolean;\n    recordCanvas: boolean;\n    keepIframeSrcFn: KeepIframeSrcFn;\n    /**\n     * `newlyAddedElement: true` skips scrollTop and scrollLeft check\n     */\n    newlyAddedElement?: boolean;\n    rootId: number | undefined;\n  },\n): serializedNode | false {\n  const {\n    doc,\n    blockClass,\n    blockSelector,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskInputFn,\n    dataURLOptions = {},\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement = false,\n    rootId,\n  } = options;\n  const needBlock = _isBlockedElement(n, blockClass, blockSelector);\n  const tagName = getValidTagName(n);\n  let attributes: attributes = {};\n  const len = n.attributes.length;\n  for (let i = 0; i < len; i++) {\n    const attr = n.attributes[i];\n    if (!ignoreAttribute(tagName, attr.name, attr.value)) {\n      attributes[attr.name] = transformAttribute(\n        doc,\n        tagName,\n        toLowerCase(attr.name),\n        attr.value,\n      );\n    }\n  }\n  // remote css\n  if (tagName === 'link' && inlineStylesheet) {\n    const stylesheet = Array.from(doc.styleSheets).find((s) => {\n      return s.href === (n as HTMLLinkElement).href;\n    });\n    let cssText: string | null = null;\n    if (stylesheet) {\n      cssText = stringifyStylesheet(stylesheet);\n    }\n    if (cssText) {\n      delete attributes.rel;\n      delete attributes.href;\n      attributes._cssText = absoluteToStylesheet(cssText, stylesheet!.href!);\n    }\n  }\n  // dynamic stylesheet\n  if (\n    tagName === 'style' &&\n    (n as HTMLStyleElement).sheet &&\n    // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n    !(n.innerText || n.textContent || '').trim().length\n  ) {\n    const cssText = stringifyStylesheet(\n      (n as HTMLStyleElement).sheet as CSSStyleSheet,\n    );\n    if (cssText) {\n      attributes._cssText = absoluteToStylesheet(cssText, getHref(doc));\n    }\n  }\n  // form fields\n  if (tagName === 'input' || tagName === 'textarea' || tagName === 'select') {\n    const value = (n as HTMLInputElement | HTMLTextAreaElement).value;\n    const checked = (n as HTMLInputElement).checked;\n    if (\n      attributes.type !== 'radio' &&\n      attributes.type !== 'checkbox' &&\n      attributes.type !== 'submit' &&\n      attributes.type !== 'button' &&\n      value\n    ) {\n      attributes.value = maskInputValue({\n        element: n,\n        type: getInputType(n),\n        tagName,\n        value,\n        maskInputOptions,\n        maskInputFn,\n      });\n    } else if (checked) {\n      attributes.checked = checked;\n    }\n  }\n  if (tagName === 'option') {\n    if ((n as HTMLOptionElement).selected && !maskInputOptions['select']) {\n      attributes.selected = true;\n    } else {\n      // ignore the html attribute (which corresponds to DOM (n as HTMLOptionElement).defaultSelected)\n      // if it's already been changed\n      delete attributes.selected;\n    }\n  }\n  // canvas image data\n  if (tagName === 'canvas' && recordCanvas) {\n    if ((n as ICanvas).__context === '2d') {\n      // only record this on 2d canvas\n      if (!is2DCanvasBlank(n as HTMLCanvasElement)) {\n        attributes.rr_dataURL = (n as HTMLCanvasElement).toDataURL(\n          dataURLOptions.type,\n          dataURLOptions.quality,\n        );\n      }\n    } else if (!('__context' in n)) {\n      // context is unknown, better not call getContext to trigger it\n      const canvasDataURL = (n as HTMLCanvasElement).toDataURL(\n        dataURLOptions.type,\n        dataURLOptions.quality,\n      );\n\n      // create blank canvas of same dimensions\n      const blankCanvas = doc.createElement('canvas');\n      blankCanvas.width = (n as HTMLCanvasElement).width;\n      blankCanvas.height = (n as HTMLCanvasElement).height;\n      const blankCanvasDataURL = blankCanvas.toDataURL(\n        dataURLOptions.type,\n        dataURLOptions.quality,\n      );\n\n      // no need to save dataURL if it's the same as blank canvas\n      if (canvasDataURL !== blankCanvasDataURL) {\n        attributes.rr_dataURL = canvasDataURL;\n      }\n    }\n  }\n  // save image offline\n  if (tagName === 'img' && inlineImages) {\n    if (!canvasService) {\n      canvasService = doc.createElement('canvas');\n      canvasCtx = canvasService.getContext('2d');\n    }\n    const image = n as HTMLImageElement;\n    const imageSrc: string =\n      image.currentSrc || image.getAttribute('src') || '<unknown-src>';\n    const priorCrossOrigin = image.crossOrigin;\n    const recordInlineImage = () => {\n      image.removeEventListener('load', recordInlineImage);\n      try {\n        canvasService!.width = image.naturalWidth;\n        canvasService!.height = image.naturalHeight;\n        canvasCtx!.drawImage(image, 0, 0);\n        attributes.rr_dataURL = canvasService!.toDataURL(\n          dataURLOptions.type,\n          dataURLOptions.quality,\n        );\n      } catch (err) {\n        if (image.crossOrigin !== 'anonymous') {\n          image.crossOrigin = 'anonymous';\n          if (image.complete && image.naturalWidth !== 0)\n            recordInlineImage(); // too early due to image reload\n          else image.addEventListener('load', recordInlineImage);\n          return;\n        } else {\n          console.warn(\n            `Cannot inline img src=${imageSrc}! Error: ${err as string}`,\n          );\n        }\n      }\n      if (image.crossOrigin === 'anonymous') {\n        priorCrossOrigin\n          ? (attributes.crossOrigin = priorCrossOrigin)\n          : image.removeAttribute('crossorigin');\n      }\n    };\n    // The image content may not have finished loading yet.\n    if (image.complete && image.naturalWidth !== 0) recordInlineImage();\n    else image.addEventListener('load', recordInlineImage);\n  }\n  // media elements\n  if (tagName === 'audio' || tagName === 'video') {\n    const mediaAttributes = attributes as mediaAttributes;\n    mediaAttributes.rr_mediaState = (n as HTMLMediaElement).paused\n      ? 'paused'\n      : 'played';\n    mediaAttributes.rr_mediaCurrentTime = (n as HTMLMediaElement).currentTime;\n    mediaAttributes.rr_mediaPlaybackRate = (n as HTMLMediaElement).playbackRate;\n    mediaAttributes.rr_mediaMuted = (n as HTMLMediaElement).muted;\n    mediaAttributes.rr_mediaLoop = (n as HTMLMediaElement).loop;\n    mediaAttributes.rr_mediaVolume = (n as HTMLMediaElement).volume;\n  }\n  // Scroll\n  if (!newlyAddedElement) {\n    // `scrollTop` and `scrollLeft` are expensive calls because they trigger reflow.\n    // Since `scrollTop` & `scrollLeft` are always 0 when an element is added to the DOM.\n    // And scrolls also get picked up by rrweb's ScrollObserver\n    // So we can safely skip the `scrollTop/Left` calls for newly added elements\n    if (n.scrollLeft) {\n      attributes.rr_scrollLeft = n.scrollLeft;\n    }\n    if (n.scrollTop) {\n      attributes.rr_scrollTop = n.scrollTop;\n    }\n  }\n  // block element\n  if (needBlock) {\n    const { width, height } = n.getBoundingClientRect();\n    attributes = {\n      class: attributes.class,\n      rr_width: `${width}px`,\n      rr_height: `${height}px`,\n    };\n  }\n  // iframe\n  if (tagName === 'iframe' && !keepIframeSrcFn(attributes.src as string)) {\n    if (!(n as HTMLIFrameElement).contentDocument) {\n      // we can't record it directly as we can't see into it\n      // preserve the src attribute so a decision can be taken at replay time\n      attributes.rr_src = attributes.src;\n    }\n    delete attributes.src; // prevent auto loading\n  }\n\n  let isCustomElement: true | undefined;\n  try {\n    if (customElements.get(tagName)) isCustomElement = true;\n  } catch (e) {\n    // In case old browsers don't support customElements\n  }\n\n  return {\n    type: NodeType.Element,\n    tagName,\n    attributes,\n    childNodes: [],\n    isSVG: isSVGElement(n as Element) || undefined,\n    needBlock,\n    rootId,\n    isCustom: isCustomElement,\n  };\n}\n\nfunction lowerIfExists(\n  maybeAttr: string | number | boolean | undefined | null,\n): string {\n  if (maybeAttr === undefined || maybeAttr === null) {\n    return '';\n  } else {\n    return (maybeAttr as string).toLowerCase();\n  }\n}\n\nfunction slimDOMExcluded(\n  sn: serializedNode,\n  slimDOMOptions: SlimDOMOptions,\n): boolean {\n  if (slimDOMOptions.comment && sn.type === NodeType.Comment) {\n    // TODO: convert IE conditional comments to real nodes\n    return true;\n  } else if (sn.type === NodeType.Element) {\n    if (\n      slimDOMOptions.script &&\n      // script tag\n      (sn.tagName === 'script' ||\n        // (module)preload link\n        (sn.tagName === 'link' &&\n          (sn.attributes.rel === 'preload' ||\n            sn.attributes.rel === 'modulepreload') &&\n          sn.attributes.as === 'script') ||\n        // prefetch link\n        (sn.tagName === 'link' &&\n          sn.attributes.rel === 'prefetch' &&\n          typeof sn.attributes.href === 'string' &&\n          extractFileExtension(sn.attributes.href) === 'js'))\n    ) {\n      return true;\n    } else if (\n      slimDOMOptions.headFavicon &&\n      ((sn.tagName === 'link' && sn.attributes.rel === 'shortcut icon') ||\n        (sn.tagName === 'meta' &&\n          (lowerIfExists(sn.attributes.name).match(\n            /^msapplication-tile(image|color)$/,\n          ) ||\n            lowerIfExists(sn.attributes.name) === 'application-name' ||\n            lowerIfExists(sn.attributes.rel) === 'icon' ||\n            lowerIfExists(sn.attributes.rel) === 'apple-touch-icon' ||\n            lowerIfExists(sn.attributes.rel) === 'shortcut icon')))\n    ) {\n      return true;\n    } else if (sn.tagName === 'meta') {\n      if (\n        slimDOMOptions.headMetaDescKeywords &&\n        lowerIfExists(sn.attributes.name).match(/^description|keywords$/)\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaSocial &&\n        (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)\n          lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) ||\n          lowerIfExists(sn.attributes.name) === 'pinterest')\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaRobots &&\n        (lowerIfExists(sn.attributes.name) === 'robots' ||\n          lowerIfExists(sn.attributes.name) === 'googlebot' ||\n          lowerIfExists(sn.attributes.name) === 'bingbot')\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaHttpEquiv &&\n        sn.attributes['http-equiv'] !== undefined\n      ) {\n        // e.g. X-UA-Compatible, Content-Type, Content-Language,\n        // cache-control, X-Translated-By\n        return true;\n      } else if (\n        slimDOMOptions.headMetaAuthorship &&\n        (lowerIfExists(sn.attributes.name) === 'author' ||\n          lowerIfExists(sn.attributes.name) === 'generator' ||\n          lowerIfExists(sn.attributes.name) === 'framework' ||\n          lowerIfExists(sn.attributes.name) === 'publisher' ||\n          lowerIfExists(sn.attributes.name) === 'progid' ||\n          lowerIfExists(sn.attributes.property).match(/^article:/) ||\n          lowerIfExists(sn.attributes.property).match(/^product:/))\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaVerification &&\n        (lowerIfExists(sn.attributes.name) === 'google-site-verification' ||\n          lowerIfExists(sn.attributes.name) === 'yandex-verification' ||\n          lowerIfExists(sn.attributes.name) === 'csrf-token' ||\n          lowerIfExists(sn.attributes.name) === 'p:domain_verify' ||\n          lowerIfExists(sn.attributes.name) === 'verify-v1' ||\n          lowerIfExists(sn.attributes.name) === 'verification' ||\n          lowerIfExists(sn.attributes.name) === 'shopify-checkout-api-token')\n      ) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nexport function serializeNodeWithId(\n  n: Node,\n  options: {\n    doc: Document;\n    mirror: Mirror;\n    blockClass: string | RegExp;\n    blockSelector: string | null;\n    maskTextClass: string | RegExp;\n    maskTextSelector: string | null;\n    skipChild: boolean;\n    inlineStylesheet: boolean;\n    newlyAddedElement?: boolean;\n    maskInputOptions?: MaskInputOptions;\n    needsMask?: boolean;\n    maskTextFn: MaskTextFn | undefined;\n    maskInputFn: MaskInputFn | undefined;\n    slimDOMOptions: SlimDOMOptions;\n    dataURLOptions?: DataURLOptions;\n    keepIframeSrcFn?: KeepIframeSrcFn;\n    inlineImages?: boolean;\n    recordCanvas?: boolean;\n    preserveWhiteSpace?: boolean;\n    onSerialize?: (n: Node) => unknown;\n    onIframeLoad?: (\n      iframeNode: HTMLIFrameElement,\n      node: serializedElementNodeWithId,\n    ) => unknown;\n    iframeLoadTimeout?: number;\n    onStylesheetLoad?: (\n      linkNode: HTMLLinkElement,\n      node: serializedElementNodeWithId,\n    ) => unknown;\n    stylesheetLoadTimeout?: number;\n  },\n): serializedNodeWithId | null {\n  const {\n    doc,\n    mirror,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    skipChild = false,\n    inlineStylesheet = true,\n    maskInputOptions = {},\n    maskTextFn,\n    maskInputFn,\n    slimDOMOptions,\n    dataURLOptions = {},\n    inlineImages = false,\n    recordCanvas = false,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout = 5000,\n    onStylesheetLoad,\n    stylesheetLoadTimeout = 5000,\n    keepIframeSrcFn = () => false,\n    newlyAddedElement = false,\n  } = options;\n  let { needsMask } = options;\n  let { preserveWhiteSpace = true } = options;\n\n  if (!needsMask) {\n    // perf: if needsMask = true, children won't also need to check\n    const checkAncestors = needsMask === undefined; // if false, we've already checked ancestors\n    needsMask = needMaskingText(\n      n as Element,\n      maskTextClass,\n      maskTextSelector,\n      checkAncestors,\n    );\n  }\n\n  const _serializedNode = serializeNode(n, {\n    doc,\n    mirror,\n    blockClass,\n    blockSelector,\n    needsMask,\n    inlineStylesheet,\n    maskInputOptions,\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions,\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement,\n  });\n  if (!_serializedNode) {\n    // TODO: dev only\n    console.warn(n, 'not serialized');\n    return null;\n  }\n\n  let id: number | undefined;\n  if (mirror.hasNode(n)) {\n    // Reuse the previous id\n    id = mirror.getId(n);\n  } else if (\n    slimDOMExcluded(_serializedNode, slimDOMOptions) ||\n    (!preserveWhiteSpace &&\n      _serializedNode.type === NodeType.Text &&\n      !_serializedNode.isStyle &&\n      !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, '').length)\n  ) {\n    id = IGNORED_NODE;\n  } else {\n    id = genId();\n  }\n\n  const serializedNode = Object.assign(_serializedNode, { id });\n  // add IGNORED_NODE to mirror to track nextSiblings\n  mirror.add(n, serializedNode);\n\n  if (id === IGNORED_NODE) {\n    return null; // slimDOM\n  }\n\n  if (onSerialize) {\n    onSerialize(n);\n  }\n  let recordChild = !skipChild;\n  if (serializedNode.type === NodeType.Element) {\n    recordChild = recordChild && !serializedNode.needBlock;\n    // this property was not needed in replay side\n    delete serializedNode.needBlock;\n    const shadowRoot = (n as HTMLElement).shadowRoot;\n    if (shadowRoot && isNativeShadowDom(shadowRoot))\n      serializedNode.isShadowHost = true;\n  }\n  if (\n    (serializedNode.type === NodeType.Document ||\n      serializedNode.type === NodeType.Element) &&\n    recordChild\n  ) {\n    if (\n      slimDOMOptions.headWhitespace &&\n      serializedNode.type === NodeType.Element &&\n      serializedNode.tagName === 'head'\n      // would impede performance: || getComputedStyle(n)['white-space'] === 'normal'\n    ) {\n      preserveWhiteSpace = false;\n    }\n    const bypassOptions = {\n      doc,\n      mirror,\n      blockClass,\n      blockSelector,\n      needsMask,\n      maskTextClass,\n      maskTextSelector,\n      skipChild,\n      inlineStylesheet,\n      maskInputOptions,\n      maskTextFn,\n      maskInputFn,\n      slimDOMOptions,\n      dataURLOptions,\n      inlineImages,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n      onStylesheetLoad,\n      stylesheetLoadTimeout,\n      keepIframeSrcFn,\n    };\n\n    if (\n      serializedNode.type === NodeType.Element &&\n      serializedNode.tagName === 'textarea' &&\n      (serializedNode as elementNode).attributes.value !== undefined\n    ) {\n      // value parameter in DOM reflects the correct value, so ignore childNode\n    } else {\n      for (const childN of Array.from(n.childNodes)) {\n        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n        if (serializedChildNode) {\n          serializedNode.childNodes.push(serializedChildNode);\n        }\n      }\n    }\n\n    if (isElement(n) && n.shadowRoot) {\n      for (const childN of Array.from(n.shadowRoot.childNodes)) {\n        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n        if (serializedChildNode) {\n          isNativeShadowDom(n.shadowRoot) &&\n            (serializedChildNode.isShadow = true);\n          serializedNode.childNodes.push(serializedChildNode);\n        }\n      }\n    }\n  }\n\n  if (\n    n.parentNode &&\n    isShadowRoot(n.parentNode) &&\n    isNativeShadowDom(n.parentNode)\n  ) {\n    serializedNode.isShadow = true;\n  }\n\n  if (\n    serializedNode.type === NodeType.Element &&\n    serializedNode.tagName === 'iframe'\n  ) {\n    onceIframeLoaded(\n      n as HTMLIFrameElement,\n      () => {\n        const iframeDoc = (n as HTMLIFrameElement).contentDocument;\n        if (iframeDoc && onIframeLoad) {\n          const serializedIframeNode = serializeNodeWithId(iframeDoc, {\n            doc: iframeDoc,\n            mirror,\n            blockClass,\n            blockSelector,\n            needsMask,\n            maskTextClass,\n            maskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputOptions,\n            maskTextFn,\n            maskInputFn,\n            slimDOMOptions,\n            dataURLOptions,\n            inlineImages,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n            onStylesheetLoad,\n            stylesheetLoadTimeout,\n            keepIframeSrcFn,\n          });\n\n          if (serializedIframeNode) {\n            onIframeLoad(\n              n as HTMLIFrameElement,\n              serializedIframeNode as serializedElementNodeWithId,\n            );\n          }\n        }\n      },\n      iframeLoadTimeout,\n    );\n  }\n\n  // <link rel=stylesheet href=...>\n  if (\n    serializedNode.type === NodeType.Element &&\n    serializedNode.tagName === 'link' &&\n    typeof serializedNode.attributes.rel === 'string' &&\n    (serializedNode.attributes.rel === 'stylesheet' ||\n      (serializedNode.attributes.rel === 'preload' &&\n        typeof serializedNode.attributes.href === 'string' &&\n        extractFileExtension(serializedNode.attributes.href) === 'css'))\n  ) {\n    onceStylesheetLoaded(\n      n as HTMLLinkElement,\n      () => {\n        if (onStylesheetLoad) {\n          const serializedLinkNode = serializeNodeWithId(n, {\n            doc,\n            mirror,\n            blockClass,\n            blockSelector,\n            needsMask,\n            maskTextClass,\n            maskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputOptions,\n            maskTextFn,\n            maskInputFn,\n            slimDOMOptions,\n            dataURLOptions,\n            inlineImages,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n            onStylesheetLoad,\n            stylesheetLoadTimeout,\n            keepIframeSrcFn,\n          });\n\n          if (serializedLinkNode) {\n            onStylesheetLoad(\n              n as HTMLLinkElement,\n              serializedLinkNode as serializedElementNodeWithId,\n            );\n          }\n        }\n      },\n      stylesheetLoadTimeout,\n    );\n  }\n\n  return serializedNode;\n}\n\nfunction snapshot(\n  n: Document,\n  options?: {\n    mirror?: Mirror;\n    blockClass?: string | RegExp;\n    blockSelector?: string | null;\n    maskTextClass?: string | RegExp;\n    maskTextSelector?: string | null;\n    inlineStylesheet?: boolean;\n    maskAllInputs?: boolean | MaskInputOptions;\n    maskTextFn?: MaskTextFn;\n    maskInputFn?: MaskInputFn;\n    slimDOM?: 'all' | boolean | SlimDOMOptions;\n    dataURLOptions?: DataURLOptions;\n    inlineImages?: boolean;\n    recordCanvas?: boolean;\n    preserveWhiteSpace?: boolean;\n    onSerialize?: (n: Node) => unknown;\n    onIframeLoad?: (\n      iframeNode: HTMLIFrameElement,\n      node: serializedElementNodeWithId,\n    ) => unknown;\n    iframeLoadTimeout?: number;\n    onStylesheetLoad?: (\n      linkNode: HTMLLinkElement,\n      node: serializedElementNodeWithId,\n    ) => unknown;\n    stylesheetLoadTimeout?: number;\n    keepIframeSrcFn?: KeepIframeSrcFn;\n  },\n): serializedNodeWithId | null {\n  const {\n    mirror = new Mirror(),\n    blockClass = 'rr-block',\n    blockSelector = null,\n    maskTextClass = 'rr-mask',\n    maskTextSelector = null,\n    inlineStylesheet = true,\n    inlineImages = false,\n    recordCanvas = false,\n    maskAllInputs = false,\n    maskTextFn,\n    maskInputFn,\n    slimDOM = false,\n    dataURLOptions,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n    onStylesheetLoad,\n    stylesheetLoadTimeout,\n    keepIframeSrcFn = () => false,\n  } = options || {};\n  const maskInputOptions: MaskInputOptions =\n    maskAllInputs === true\n      ? {\n          color: true,\n          date: true,\n          'datetime-local': true,\n          email: true,\n          month: true,\n          number: true,\n          range: true,\n          search: true,\n          tel: true,\n          text: true,\n          time: true,\n          url: true,\n          week: true,\n          textarea: true,\n          select: true,\n          password: true,\n        }\n      : maskAllInputs === false\n      ? {\n          password: true,\n        }\n      : maskAllInputs;\n  const slimDOMOptions: SlimDOMOptions =\n    slimDOM === true || slimDOM === 'all'\n      ? // if true: set of sensible options that should not throw away any information\n        {\n          script: true,\n          comment: true,\n          headFavicon: true,\n          headWhitespace: true,\n          headMetaDescKeywords: slimDOM === 'all', // destructive\n          headMetaSocial: true,\n          headMetaRobots: true,\n          headMetaHttpEquiv: true,\n          headMetaAuthorship: true,\n          headMetaVerification: true,\n        }\n      : slimDOM === false\n      ? {}\n      : slimDOM;\n  return serializeNodeWithId(n, {\n    doc: n,\n    mirror,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    skipChild: false,\n    inlineStylesheet,\n    maskInputOptions,\n    maskTextFn,\n    maskInputFn,\n    slimDOMOptions,\n    dataURLOptions,\n    inlineImages,\n    recordCanvas,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n    onStylesheetLoad,\n    stylesheetLoadTimeout,\n    keepIframeSrcFn,\n    newlyAddedElement: false,\n  });\n}\n\nexport function visitSnapshot(\n  node: serializedNodeWithId,\n  onVisit: (node: serializedNodeWithId) => unknown,\n) {\n  function walk(current: serializedNodeWithId) {\n    onVisit(current);\n    if (\n      current.type === NodeType.Document ||\n      current.type === NodeType.Element\n    ) {\n      current.childNodes.forEach(walk);\n    }\n  }\n\n  walk(node);\n}\n\nexport function cleanupSnapshot() {\n  // allow a new recording to start numbering nodes from scratch\n  _id = 1;\n}\n\nexport default snapshot;\n", "/**\n * This file is a fork of https://github.com/reworkcss/css/blob/master/lib/parse/index.js\n * I fork it because:\n * 1. The css library was built for node.js which does not have tree-shaking supports.\n * 2. Rewrites into typescript give us a better type interface.\n */\n/* eslint-disable tsdoc/syntax */\n\nexport interface ParserOptions {\n  /** Silently fail on parse errors */\n  silent?: boolean;\n  /**\n   * The path to the file containing css.\n   * Makes errors and source maps more helpful, by letting them know where code comes from.\n   */\n  source?: string;\n}\n\n/**\n * Error thrown during parsing.\n */\nexport interface ParserError {\n  /** The full error message with the source position. */\n  message?: string;\n  /** The error message without position. */\n  reason?: string;\n  /** The value of options.source if passed to css.parse. Otherwise undefined. */\n  filename?: string;\n  line?: number;\n  column?: number;\n  /** The portion of code that couldn't be parsed. */\n  source?: string;\n}\n\nexport interface Loc {\n  line?: number;\n  column?: number;\n}\n\n/**\n * Base AST Tree Node.\n */\nexport interface Node {\n  /** The possible values are the ones listed in the Types section on https://github.com/reworkcss/css page. */\n  type?: string;\n  /** A reference to the parent node, or null if the node has no parent. */\n  parent?: Node;\n  /** Information about the position in the source string that corresponds to the node. */\n  position?: {\n    start?: Loc;\n    end?: Loc;\n    /** The value of options.source if passed to css.parse. Otherwise undefined. */\n    source?: string;\n    /** The full source string passed to css.parse. */\n    content?: string;\n  };\n}\n\nexport interface NodeWithRules extends Node {\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules: Array<Rule | Comment | AtRule>;\n}\n\nexport interface Rule extends Node {\n  /** The list of selectors of the rule, split on commas. Each selector is trimmed from whitespace and comments. */\n  selectors?: string[];\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\nexport interface Declaration extends Node {\n  /** The property name, trimmed from whitespace and comments. May not be empty. */\n  property?: string;\n  /** The value of the property, trimmed from whitespace and comments. Empty values are allowed. */\n  value?: string;\n}\n\n/**\n * A rule-level or declaration-level comment. Comments inside selectors, properties and values etc. are lost.\n */\nexport interface Comment extends Node {\n  comment?: string;\n}\n\n/**\n * The @charset at-rule.\n */\nexport interface Charset extends Node {\n  /** The part following @charset. */\n  charset?: string;\n}\n\n/**\n * The @custom-media at-rule\n */\nexport interface CustomMedia extends Node {\n  /** The ---prefixed name. */\n  name?: string;\n  /** The part following the name. */\n  media?: string;\n}\n\n/**\n * The @document at-rule.\n */\nexport interface Document extends NodeWithRules {\n  /** The part following @document. */\n  document?: string;\n  /** The vendor prefix in @document, or undefined if there is none. */\n  vendor?: string;\n}\n\n/**\n * The @font-face at-rule.\n */\nexport interface FontFace extends Node {\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\n/**\n * The @host at-rule.\n */\nexport type Host = NodeWithRules;\n\n/**\n * The @import at-rule.\n */\nexport interface Import extends Node {\n  /** The part following @import. */\n  import?: string;\n}\n\n/**\n * The @keyframes at-rule.\n */\nexport interface KeyFrames extends Node {\n  /** The name of the keyframes rule. */\n  name?: string;\n  /** The vendor prefix in @keyframes, or undefined if there is none. */\n  vendor?: string;\n  /** Array of nodes with the types keyframe and comment. */\n  keyframes?: Array<KeyFrame | Comment>;\n}\n\nexport interface KeyFrame extends Node {\n  /** The list of \"selectors\" of the keyframe rule, split on commas. Each selector is trimmed from whitespace. */\n  values?: string[];\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\n/**\n * The @media at-rule.\n */\nexport interface Media extends NodeWithRules {\n  /** The part following @media. */\n  media?: string;\n}\n\n/**\n * The @namespace at-rule.\n */\nexport interface Namespace extends Node {\n  /** The part following @namespace. */\n  namespace?: string;\n}\n\n/**\n * The @page at-rule.\n */\nexport interface Page extends Node {\n  /** The list of selectors of the rule, split on commas. Each selector is trimmed from whitespace and comments. */\n  selectors?: string[];\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\n/**\n * The @supports at-rule.\n */\nexport interface Supports extends NodeWithRules {\n  /** The part following @supports. */\n  supports?: string;\n}\n\n/** All at-rules. */\nexport type AtRule =\n  | Charset\n  | CustomMedia\n  | Document\n  | FontFace\n  | Host\n  | Import\n  | KeyFrames\n  | Media\n  | Namespace\n  | Page\n  | Supports;\n\n/**\n * A collection of rules\n */\nexport interface StyleRules extends NodeWithRules {\n  source?: string;\n  /** Array of Errors. Errors collected during parsing when option silent is true. */\n  parsingErrors?: ParserError[];\n}\n\n/**\n * The root node returned by css.parse.\n */\nexport interface Stylesheet extends Node {\n  stylesheet?: StyleRules;\n}\n\n// http://www.w3.org/TR/CSS21/grammar.html\n// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027\nconst commentre = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\n\nexport function parse(css: string, options: ParserOptions = {}): Stylesheet {\n  /**\n   * Positional.\n   */\n\n  let lineno = 1;\n  let column = 1;\n\n  /**\n   * Update lineno and column based on `str`.\n   */\n\n  function updatePosition(str: string) {\n    const lines = str.match(/\\n/g);\n    if (lines) {\n      lineno += lines.length;\n    }\n    const i = str.lastIndexOf('\\n');\n    column = i === -1 ? column + str.length : str.length - i;\n  }\n\n  /**\n   * Mark position and patch `node.position`.\n   */\n\n  function position() {\n    const start = { line: lineno, column };\n    return (\n      node: Rule | Declaration | Comment | AtRule | Stylesheet | KeyFrame,\n    ) => {\n      node.position = new Position(start);\n      whitespace();\n      return node;\n    };\n  }\n\n  /**\n   * Store position information for a node\n   */\n\n  class Position {\n    public static content: string;\n    public content!: string;\n    public start!: Loc;\n    public end!: Loc;\n    public source?: string;\n\n    constructor(start: Loc) {\n      this.start = start;\n      this.end = { line: lineno, column };\n      this.source = options.source;\n      this.content = Position.content;\n    }\n  }\n\n  /**\n   * Non-enumerable source string\n   */\n\n  Position.content = css;\n\n  const errorsList: ParserError[] = [];\n\n  function error(msg: string) {\n    const err = new Error(\n      `${options.source || ''}:${lineno}:${column}: ${msg}`,\n    ) as ParserError;\n    err.reason = msg;\n    err.filename = options.source;\n    err.line = lineno;\n    err.column = column;\n    err.source = css;\n\n    if (options.silent) {\n      errorsList.push(err);\n    } else {\n      throw err;\n    }\n  }\n\n  /**\n   * Parse stylesheet.\n   */\n\n  function stylesheet(): Stylesheet {\n    const rulesList = rules();\n\n    return {\n      type: 'stylesheet',\n      stylesheet: {\n        source: options.source,\n        rules: rulesList,\n        parsingErrors: errorsList,\n      },\n    };\n  }\n\n  /**\n   * Opening brace.\n   */\n\n  function open() {\n    return match(/^{\\s*/);\n  }\n\n  /**\n   * Closing brace.\n   */\n\n  function close() {\n    return match(/^}/);\n  }\n\n  /**\n   * Parse ruleset.\n   */\n\n  function rules() {\n    let node: Rule | void;\n    const rules: Rule[] = [];\n    whitespace();\n    comments(rules);\n    while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {\n      if (node) {\n        rules.push(node);\n        comments(rules);\n      }\n    }\n    return rules;\n  }\n\n  /**\n   * Match `re` and return captures.\n   */\n\n  function match(re: RegExp) {\n    const m = re.exec(css);\n    if (!m) {\n      return;\n    }\n    const str = m[0];\n    updatePosition(str);\n    css = css.slice(str.length);\n    return m;\n  }\n\n  /**\n   * Parse whitespace.\n   */\n\n  function whitespace() {\n    match(/^\\s*/);\n  }\n\n  /**\n   * Parse comments;\n   */\n\n  function comments(rules: Rule[] = []) {\n    let c: Comment | void;\n    while ((c = comment())) {\n      if (c) {\n        rules.push(c);\n      }\n      c = comment();\n    }\n    return rules;\n  }\n\n  /**\n   * Parse comment.\n   */\n\n  function comment() {\n    const pos = position();\n    if ('/' !== css.charAt(0) || '*' !== css.charAt(1)) {\n      return;\n    }\n\n    let i = 2;\n    while (\n      '' !== css.charAt(i) &&\n      ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1))\n    ) {\n      ++i;\n    }\n    i += 2;\n\n    if ('' === css.charAt(i - 1)) {\n      return error('End of comment missing');\n    }\n\n    const str = css.slice(2, i - 2);\n    column += 2;\n    updatePosition(str);\n    css = css.slice(i);\n    column += 2;\n\n    return pos({\n      type: 'comment',\n      comment: str,\n    });\n  }\n\n  /**\n   * Parse selector.\n   */\n\n  // originally from https://github.com/NxtChg/pieces/blob/3eb39c8287a97632e9347a24f333d52d916bc816/js/css_parser/css_parse.js#L46C1-L47C1\n  const selectorMatcher = new RegExp(\n    '^((' +\n      [\n        /[^\\\\]\"(?:\\\\\"|[^\"])*\"/.source, // consume any quoted parts (checking that the double quote isn't itself escaped)\n        /[^\\\\]'(?:\\\\'|[^'])*'/.source, // same but for single quotes\n        '[^{]',\n      ].join('|') +\n      ')+)',\n  );\n\n  function selector() {\n    whitespace();\n    while (css[0] == '}') {\n      error('extra closing bracket');\n      css = css.slice(1);\n      whitespace();\n    }\n\n    const m = match(selectorMatcher);\n    if (!m) {\n      return;\n    }\n\n    /* @fix Remove all comments from selectors\n     * http://ostermiller.org/findcomment.html */\n    const cleanedInput = m[0]\n      .trim()\n      .replace(/\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*\\/+/g, '')\n\n      // Handle strings by replacing commas inside them\n      .replace(/\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'/g, (m) => {\n        return m.replace(/,/g, '\\u200C');\n      });\n\n    // Split using a custom function and restore commas in strings\n    return customSplit(cleanedInput).map((s) =>\n      s.replace(/\\u200C/g, ',').trim(),\n    );\n  }\n\n  /**\n   * Split selector correctly, ensuring not to split on comma if inside ().\n   */\n\n  function customSplit(input: string) {\n    const result = [];\n    let currentSegment = '';\n    let depthParentheses = 0; // Track depth of parentheses\n    let depthBrackets = 0; // Track depth of square brackets\n    let currentStringChar = null;\n\n    for (const char of input) {\n      const hasStringEscape = currentSegment.endsWith('\\\\');\n\n      if (currentStringChar) {\n        if (currentStringChar === char && !hasStringEscape) {\n          currentStringChar = null;\n        }\n      } else if (char === '(') {\n        depthParentheses++;\n      } else if (char === ')') {\n        depthParentheses--;\n      } else if (char === '[') {\n        depthBrackets++;\n      } else if (char === ']') {\n        depthBrackets--;\n      } else if ('\\'\"'.includes(char)) {\n        currentStringChar = char;\n      }\n\n      // Split point is a comma that is not inside parentheses or square brackets\n      if (char === ',' && depthParentheses === 0 && depthBrackets === 0) {\n        result.push(currentSegment);\n        currentSegment = '';\n      } else {\n        currentSegment += char;\n      }\n    }\n\n    // Add the last segment\n    if (currentSegment) {\n      result.push(currentSegment);\n    }\n\n    return result;\n  }\n\n  /**\n   * Parse declaration.\n   */\n\n  function declaration(): Declaration | void | never {\n    const pos = position();\n\n    // prop\n    // eslint-disable-next-line no-useless-escape\n    const propMatch = match(/^(\\*?[-#\\/\\*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/);\n    if (!propMatch) {\n      return;\n    }\n    const prop = trim(propMatch[0]);\n\n    // :\n    if (!match(/^:\\s*/)) {\n      return error(`property missing ':'`);\n    }\n\n    // val\n    // eslint-disable-next-line no-useless-escape\n    const val = match(/^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+)/);\n\n    const ret = pos({\n      type: 'declaration',\n      property: prop.replace(commentre, ''),\n      value: val ? trim(val[0]).replace(commentre, '') : '',\n    });\n\n    // ;\n    match(/^[;\\s]*/);\n\n    return ret;\n  }\n\n  /**\n   * Parse declarations.\n   */\n\n  function declarations() {\n    const decls: Array<object> = [];\n\n    if (!open()) {\n      return error(`missing '{'`);\n    }\n    comments(decls);\n\n    // declarations\n    let decl;\n    while ((decl = declaration())) {\n      if ((decl as unknown) !== false) {\n        decls.push(decl);\n        comments(decls);\n      }\n      decl = declaration();\n    }\n\n    if (!close()) {\n      return error(`missing '}'`);\n    }\n    return decls;\n  }\n\n  /**\n   * Parse keyframe.\n   */\n\n  function keyframe() {\n    let m;\n    const vals = [];\n    const pos = position();\n\n    while ((m = match(/^((\\d+\\.\\d+|\\.\\d+|\\d+)%?|[a-z]+)\\s*/))) {\n      vals.push(m[1]);\n      match(/^,\\s*/);\n    }\n\n    if (!vals.length) {\n      return;\n    }\n\n    return pos({\n      type: 'keyframe',\n      values: vals,\n      declarations: declarations() as Declaration[],\n    });\n  }\n\n  /**\n   * Parse keyframes.\n   */\n\n  function atkeyframes() {\n    const pos = position();\n    let m = match(/^@([-\\w]+)?keyframes\\s*/);\n\n    if (!m) {\n      return;\n    }\n    const vendor = m[1];\n\n    // identifier\n    m = match(/^([-\\w]+)\\s*/);\n    if (!m) {\n      return error('@keyframes missing name');\n    }\n    const name = m[1];\n\n    if (!open()) {\n      return error(`@keyframes missing '{'`);\n    }\n\n    let frame;\n    let frames = comments();\n    while ((frame = keyframe())) {\n      frames.push(frame);\n      frames = frames.concat(comments());\n    }\n\n    if (!close()) {\n      return error(`@keyframes missing '}'`);\n    }\n\n    return pos({\n      type: 'keyframes',\n      name,\n      vendor,\n      keyframes: frames,\n    });\n  }\n\n  /**\n   * Parse supports.\n   */\n\n  function atsupports() {\n    const pos = position();\n    const m = match(/^@supports *([^{]+)/);\n\n    if (!m) {\n      return;\n    }\n    const supports = trim(m[1]);\n\n    if (!open()) {\n      return error(`@supports missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@supports missing '}'`);\n    }\n\n    return pos({\n      type: 'supports',\n      supports,\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse host.\n   */\n\n  function athost() {\n    const pos = position();\n    const m = match(/^@host\\s*/);\n\n    if (!m) {\n      return;\n    }\n\n    if (!open()) {\n      return error(`@host missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@host missing '}'`);\n    }\n\n    return pos({\n      type: 'host',\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse media.\n   */\n\n  function atmedia() {\n    const pos = position();\n    const m = match(/^@media *([^{]+)/);\n\n    if (!m) {\n      return;\n    }\n    const media = trim(m[1]);\n\n    if (!open()) {\n      return error(`@media missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@media missing '}'`);\n    }\n\n    return pos({\n      type: 'media',\n      media,\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse custom-media.\n   */\n\n  function atcustommedia() {\n    const pos = position();\n    const m = match(/^@custom-media\\s+(--[^\\s]+)\\s*([^{;]+);/);\n    if (!m) {\n      return;\n    }\n\n    return pos({\n      type: 'custom-media',\n      name: trim(m[1]),\n      media: trim(m[2]),\n    });\n  }\n\n  /**\n   * Parse paged media.\n   */\n\n  function atpage() {\n    const pos = position();\n    const m = match(/^@page */);\n    if (!m) {\n      return;\n    }\n\n    const sel = selector() || [];\n\n    if (!open()) {\n      return error(`@page missing '{'`);\n    }\n    let decls = comments();\n\n    // declarations\n    let decl;\n    while ((decl = declaration())) {\n      decls.push(decl);\n      decls = decls.concat(comments());\n    }\n\n    if (!close()) {\n      return error(`@page missing '}'`);\n    }\n\n    return pos({\n      type: 'page',\n      selectors: sel,\n      declarations: decls,\n    });\n  }\n\n  /**\n   * Parse document.\n   */\n\n  function atdocument() {\n    const pos = position();\n    const m = match(/^@([-\\w]+)?document *([^{]+)/);\n    if (!m) {\n      return;\n    }\n\n    const vendor = trim(m[1]);\n    const doc = trim(m[2]);\n\n    if (!open()) {\n      return error(`@document missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@document missing '}'`);\n    }\n\n    return pos({\n      type: 'document',\n      document: doc,\n      vendor,\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse font-face.\n   */\n\n  function atfontface() {\n    const pos = position();\n    const m = match(/^@font-face\\s*/);\n    if (!m) {\n      return;\n    }\n\n    if (!open()) {\n      return error(`@font-face missing '{'`);\n    }\n    let decls = comments();\n\n    // declarations\n    let decl;\n    while ((decl = declaration())) {\n      decls.push(decl);\n      decls = decls.concat(comments());\n    }\n\n    if (!close()) {\n      return error(`@font-face missing '}'`);\n    }\n\n    return pos({\n      type: 'font-face',\n      declarations: decls,\n    });\n  }\n\n  /**\n   * Parse import\n   */\n\n  const atimport = _compileAtrule('import');\n\n  /**\n   * Parse charset\n   */\n\n  const atcharset = _compileAtrule('charset');\n\n  /**\n   * Parse namespace\n   */\n\n  const atnamespace = _compileAtrule('namespace');\n\n  /**\n   * Parse non-block at-rules\n   */\n\n  function _compileAtrule(name: string) {\n    const re = new RegExp(\n      '^@' +\n        name +\n        '\\\\s*((?:' +\n        [\n          /[^\\\\]\"(?:\\\\\"|[^\"])*\"/.source, // consume any quoted parts (checking that the double quote isn't itself escaped)\n          /[^\\\\]'(?:\\\\'|[^'])*'/.source, // same but for single quotes\n          '[^;]',\n        ].join('|') +\n        ')+);',\n    );\n    return () => {\n      const pos = position();\n      const m = match(re);\n      if (!m) {\n        return;\n      }\n      const ret: Record<string, string> = { type: name };\n      ret[name] = m[1].trim();\n      return pos(ret);\n    };\n  }\n\n  /**\n   * Parse at rule.\n   */\n\n  function atrule() {\n    if (css[0] !== '@') {\n      return;\n    }\n\n    return (\n      atkeyframes() ||\n      atmedia() ||\n      atcustommedia() ||\n      atsupports() ||\n      atimport() ||\n      atcharset() ||\n      atnamespace() ||\n      atdocument() ||\n      atpage() ||\n      athost() ||\n      atfontface()\n    );\n  }\n\n  /**\n   * Parse rule.\n   */\n\n  function rule() {\n    const pos = position();\n    const sel = selector();\n\n    if (!sel) {\n      return error('selector missing');\n    }\n    comments();\n\n    return pos({\n      type: 'rule',\n      selectors: sel,\n      declarations: declarations() as Declaration[],\n    });\n  }\n\n  return addParent(stylesheet());\n}\n\n/**\n * Trim `str`.\n */\n\nfunction trim(str: string) {\n  return str ? str.replace(/^\\s+|\\s+$/g, '') : '';\n}\n\n/**\n * Adds non-enumerable parent node reference to each node.\n */\n\nfunction addParent(obj: Stylesheet, parent?: Stylesheet): Stylesheet {\n  const isNode = obj && typeof obj.type === 'string';\n  const childParent = isNode ? obj : parent;\n\n  for (const k of Object.keys(obj)) {\n    const value = obj[k as keyof Stylesheet];\n    if (Array.isArray(value)) {\n      value.forEach((v) => {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        addParent(v, childParent);\n      });\n    } else if (value && typeof value === 'object') {\n      addParent(value as Stylesheet, childParent);\n    }\n  }\n\n  if (isNode) {\n    Object.defineProperty(obj, 'parent', {\n      configurable: true,\n      writable: true,\n      enumerable: false,\n      value: parent || null,\n    });\n  }\n\n  return obj;\n}\n", "import { type Rule, type Media, type NodeWithRules, parse } from './css';\nimport {\n  type serializedNodeWithId,\n  NodeType,\n  type tagMap,\n  type elementNode,\n  type BuildCache,\n  type legacyAttributes,\n} from './types';\nimport { isElement, Mirror, isNodeMetaEqual } from './utils';\n\nconst tagMap: tagMap = {\n  script: 'noscript',\n  // camel case svg element tag names\n  altglyph: 'altGlyph',\n  altglyphdef: 'altGlyphDef',\n  altglyphitem: 'altGlyphItem',\n  animatecolor: 'animateColor',\n  animatemotion: 'animateMotion',\n  animatetransform: 'animateTransform',\n  clippath: 'clipPath',\n  feblend: 'feBlend',\n  fecolormatrix: 'feColorMatrix',\n  fecomponenttransfer: 'feComponentTransfer',\n  fecomposite: 'feComposite',\n  feconvolvematrix: 'feConvolveMatrix',\n  fediffuselighting: 'feDiffuseLighting',\n  fedisplacementmap: 'feDisplacementMap',\n  fedistantlight: 'feDistantLight',\n  fedropshadow: 'feDropShadow',\n  feflood: 'feFlood',\n  fefunca: 'feFuncA',\n  fefuncb: 'feFuncB',\n  fefuncg: 'feFuncG',\n  fefuncr: 'feFuncR',\n  fegaussianblur: 'feGaussianBlur',\n  feimage: 'feImage',\n  femerge: 'feMerge',\n  femergenode: 'feMergeNode',\n  femorphology: 'feMorphology',\n  feoffset: 'feOffset',\n  fepointlight: 'fePointLight',\n  fespecularlighting: 'feSpecularLighting',\n  fespotlight: 'feSpotLight',\n  fetile: 'feTile',\n  feturbulence: 'feTurbulence',\n  foreignobject: 'foreignObject',\n  glyphref: 'glyphRef',\n  lineargradient: 'linearGradient',\n  radialgradient: 'radialGradient',\n};\nfunction getTagName(n: elementNode): string {\n  let tagName = tagMap[n.tagName] ? tagMap[n.tagName] : n.tagName;\n  if (tagName === 'link' && n.attributes._cssText) {\n    tagName = 'style';\n  }\n  return tagName;\n}\n\n// based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#escaping\nfunction escapeRegExp(str: string) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nconst MEDIA_SELECTOR = /(max|min)-device-(width|height)/;\nconst MEDIA_SELECTOR_GLOBAL = new RegExp(MEDIA_SELECTOR.source, 'g');\nconst HOVER_SELECTOR = /([^\\\\]):hover/;\nconst HOVER_SELECTOR_GLOBAL = new RegExp(HOVER_SELECTOR.source, 'g');\nexport function adaptCssForReplay(cssText: string, cache: BuildCache): string {\n  const cachedStyle = cache?.stylesWithHoverClass.get(cssText);\n  if (cachedStyle) return cachedStyle;\n\n  const ast = parse(cssText, {\n    silent: true,\n  });\n\n  if (!ast.stylesheet) {\n    return cssText;\n  }\n\n  const selectors: string[] = [];\n  const medias: string[] = [];\n  function getSelectors(rule: Rule | Media | NodeWithRules) {\n    if ('selectors' in rule && rule.selectors) {\n      rule.selectors.forEach((selector: string) => {\n        if (HOVER_SELECTOR.test(selector)) {\n          selectors.push(selector);\n        }\n      });\n    }\n    if ('media' in rule && rule.media && MEDIA_SELECTOR.test(rule.media)) {\n      medias.push(rule.media);\n    }\n    if ('rules' in rule && rule.rules) {\n      rule.rules.forEach(getSelectors);\n    }\n  }\n  getSelectors(ast.stylesheet);\n\n  let result = cssText;\n  if (selectors.length > 0) {\n    const selectorMatcher = new RegExp(\n      selectors\n        .filter((selector, index) => selectors.indexOf(selector) === index)\n        .sort((a, b) => b.length - a.length)\n        .map((selector) => {\n          return escapeRegExp(selector);\n        })\n        .join('|'),\n      'g',\n    );\n    result = result.replace(selectorMatcher, (selector) => {\n      const newSelector = selector.replace(\n        HOVER_SELECTOR_GLOBAL,\n        '$1.\\\\:hover',\n      );\n      return `${selector}, ${newSelector}`;\n    });\n  }\n  if (medias.length > 0) {\n    const mediaMatcher = new RegExp(\n      medias\n        .filter((media, index) => medias.indexOf(media) === index)\n        .sort((a, b) => b.length - a.length)\n        .map((media) => {\n          return escapeRegExp(media);\n        })\n        .join('|'),\n      'g',\n    );\n    result = result.replace(mediaMatcher, (media) => {\n      // not attempting to maintain min-device-width along with min-width\n      // (it's non standard)\n      return media.replace(MEDIA_SELECTOR_GLOBAL, '$1-$2');\n    });\n  }\n  cache?.stylesWithHoverClass.set(cssText, result);\n  return result;\n}\n\nexport function createCache(): BuildCache {\n  const stylesWithHoverClass: Map<string, string> = new Map();\n  return {\n    stylesWithHoverClass,\n  };\n}\n\nfunction buildNode(\n  n: serializedNodeWithId,\n  options: {\n    doc: Document;\n    hackCss: boolean;\n    cache: BuildCache;\n  },\n): Node | null {\n  const { doc, hackCss, cache } = options;\n  switch (n.type) {\n    case NodeType.Document:\n      return doc.implementation.createDocument(null, '', null);\n    case NodeType.DocumentType:\n      return doc.implementation.createDocumentType(\n        n.name || 'html',\n        n.publicId,\n        n.systemId,\n      );\n    case NodeType.Element: {\n      const tagName = getTagName(n);\n      let node: Element;\n      if (n.isSVG) {\n        node = doc.createElementNS('http://www.w3.org/2000/svg', tagName);\n      } else {\n        if (\n          // If the tag name is a custom element name\n          n.isCustom &&\n          // If the browser supports custom elements\n          doc.defaultView?.customElements &&\n          // If the custom element hasn't been defined yet\n          !doc.defaultView.customElements.get(n.tagName)\n        )\n          doc.defaultView.customElements.define(\n            n.tagName,\n            class extends doc.defaultView.HTMLElement {},\n          );\n        node = doc.createElement(tagName);\n      }\n      /**\n       * Attribute names start with `rr_` are internal attributes added by rrweb.\n       * They often overwrite other attributes on the element.\n       * We need to parse them last so they can overwrite conflicting attributes.\n       */\n      const specialAttributes: { [key: string]: string | number } = {};\n      for (const name in n.attributes) {\n        if (!Object.prototype.hasOwnProperty.call(n.attributes, name)) {\n          continue;\n        }\n        let value = n.attributes[name];\n        if (\n          tagName === 'option' &&\n          name === 'selected' &&\n          (value as legacyAttributes[typeof name]) === false\n        ) {\n          // legacy fix (TODO: if `value === false` can be generated for other attrs,\n          // should we also omit those other attrs from build ?)\n          continue;\n        }\n\n        // null values mean the attribute was removed\n        if (value === null) {\n          continue;\n        }\n\n        /**\n         * Boolean attributes are considered to be true if they're present on the element at all.\n         * We should set value to the empty string (\"\") or the attribute's name, with no leading or trailing whitespace.\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute#parameters\n         */\n        if (value === true) value = '';\n\n        if (name.startsWith('rr_')) {\n          specialAttributes[name] = value;\n          continue;\n        }\n\n        const isTextarea = tagName === 'textarea' && name === 'value';\n        const isRemoteOrDynamicCss = tagName === 'style' && name === '_cssText';\n        if (isRemoteOrDynamicCss && hackCss && typeof value === 'string') {\n          value = adaptCssForReplay(value, cache);\n        }\n        if ((isTextarea || isRemoteOrDynamicCss) && typeof value === 'string') {\n          node.appendChild(doc.createTextNode(value));\n          // https://github.com/rrweb-io/rrweb/issues/112\n          n.childNodes = []; // value overrides childNodes\n          continue;\n        }\n\n        try {\n          if (n.isSVG && name === 'xlink:href') {\n            node.setAttributeNS(\n              'http://www.w3.org/1999/xlink',\n              name,\n              value.toString(),\n            );\n          } else if (\n            name === 'onload' ||\n            name === 'onclick' ||\n            name.substring(0, 7) === 'onmouse'\n          ) {\n            // Rename some of the more common atttributes from https://www.w3schools.com/tags/ref_eventattributes.asp\n            // as setting them triggers a console.error (which shows up despite the try/catch)\n            // Assumption: these attributes are not used to css\n            node.setAttribute('_' + name, value.toString());\n          } else if (\n            tagName === 'meta' &&\n            n.attributes['http-equiv'] === 'Content-Security-Policy' &&\n            name === 'content'\n          ) {\n            // If CSP contains style-src and inline-style is disabled, there will be an error \"Refused to apply inline style because it violates the following Content Security Policy directive: style-src '*'\".\n            // And the function insertStyleRules in rrweb replayer will throw an error \"Uncaught TypeError: Cannot read property 'insertRule' of null\".\n            node.setAttribute('csp-content', value.toString());\n            continue;\n          } else if (\n            tagName === 'link' &&\n            (n.attributes.rel === 'preload' ||\n              n.attributes.rel === 'modulepreload') &&\n            n.attributes.as === 'script'\n          ) {\n            // ignore\n          } else if (\n            tagName === 'link' &&\n            n.attributes.rel === 'prefetch' &&\n            typeof n.attributes.href === 'string' &&\n            n.attributes.href.endsWith('.js')\n          ) {\n            // ignore\n          } else if (\n            tagName === 'img' &&\n            n.attributes.srcset &&\n            n.attributes.rr_dataURL\n          ) {\n            // backup original img srcset\n            node.setAttribute(\n              'rrweb-original-srcset',\n              n.attributes.srcset as string,\n            );\n          } else {\n            node.setAttribute(name, value.toString());\n          }\n        } catch (error) {\n          // skip invalid attribute\n        }\n      }\n\n      for (const name in specialAttributes) {\n        const value = specialAttributes[name];\n        // handle internal attributes\n        if (tagName === 'canvas' && name === 'rr_dataURL') {\n          const image = doc.createElement('img');\n          image.onload = () => {\n            const ctx = (node as HTMLCanvasElement).getContext('2d');\n            if (ctx) {\n              ctx.drawImage(image, 0, 0, image.width, image.height);\n            }\n          };\n          image.src = value.toString();\n          type RRCanvasElement = {\n            RRNodeType: NodeType;\n            rr_dataURL: string;\n          };\n          // If the canvas element is created in RRDom runtime (seeking to a time point), the canvas context isn't supported. So the data has to be stored and not handled until diff process. https://github.com/rrweb-io/rrweb/pull/944\n          if ((node as unknown as RRCanvasElement).RRNodeType)\n            (node as unknown as RRCanvasElement).rr_dataURL = value.toString();\n        } else if (tagName === 'img' && name === 'rr_dataURL') {\n          const image = node as HTMLImageElement;\n          if (!image.currentSrc.startsWith('data:')) {\n            // Backup original img src. It may not have been set yet.\n            image.setAttribute(\n              'rrweb-original-src',\n              n.attributes.src as string,\n            );\n            image.src = value.toString();\n          }\n        }\n\n        if (name === 'rr_width') {\n          (node as HTMLElement).style.width = value.toString();\n        } else if (name === 'rr_height') {\n          (node as HTMLElement).style.height = value.toString();\n        } else if (\n          name === 'rr_mediaCurrentTime' &&\n          typeof value === 'number'\n        ) {\n          (node as HTMLMediaElement).currentTime = value;\n        } else if (name === 'rr_mediaState') {\n          switch (value) {\n            case 'played':\n              (node as HTMLMediaElement)\n                .play()\n                .catch((e) => console.warn('media playback error', e));\n              break;\n            case 'paused':\n              (node as HTMLMediaElement).pause();\n              break;\n            default:\n          }\n        } else if (\n          name === 'rr_mediaPlaybackRate' &&\n          typeof value === 'number'\n        ) {\n          (node as HTMLMediaElement).playbackRate = value;\n        } else if (name === 'rr_mediaMuted' && typeof value === 'boolean') {\n          (node as HTMLMediaElement).muted = value;\n        } else if (name === 'rr_mediaLoop' && typeof value === 'boolean') {\n          (node as HTMLMediaElement).loop = value;\n        } else if (name === 'rr_mediaVolume' && typeof value === 'number') {\n          (node as HTMLMediaElement).volume = value;\n        }\n      }\n\n      if (n.isShadowHost) {\n        /**\n         * Since node is newly rebuilt, it should be a normal element\n         * without shadowRoot.\n         * But if there are some weird situations that has defined\n         * custom element in the scope before we rebuild node, it may\n         * register the shadowRoot earlier.\n         * The logic in the 'else' block is just a try-my-best solution\n         * for the corner case, please let we know if it is wrong and\n         * we can remove it.\n         */\n        if (!node.shadowRoot) {\n          node.attachShadow({ mode: 'open' });\n        } else {\n          while (node.shadowRoot.firstChild) {\n            node.shadowRoot.removeChild(node.shadowRoot.firstChild);\n          }\n        }\n      }\n      return node;\n    }\n    case NodeType.Text:\n      return doc.createTextNode(\n        n.isStyle && hackCss\n          ? adaptCssForReplay(n.textContent, cache)\n          : n.textContent,\n      );\n    case NodeType.CDATA:\n      return doc.createCDATASection(n.textContent);\n    case NodeType.Comment:\n      return doc.createComment(n.textContent);\n    default:\n      return null;\n  }\n}\n\nexport function buildNodeWithSN(\n  n: serializedNodeWithId,\n  options: {\n    doc: Document;\n    mirror: Mirror;\n    skipChild?: boolean;\n    hackCss: boolean;\n    /**\n     * This callback will be called for each of this nodes' `.childNodes` after they are appended to _this_ node.\n     * Caveat: This callback _doesn't_ get called when this node is appended to the DOM.\n     */\n    afterAppend?: (n: Node, id: number) => unknown;\n    cache: BuildCache;\n  },\n): Node | null {\n  const {\n    doc,\n    mirror,\n    skipChild = false,\n    hackCss = true,\n    afterAppend,\n    cache,\n  } = options;\n  /**\n   * Add a check to see if the node is already in the mirror. If it is, we can skip the whole process.\n   * This situation (duplicated nodes) can happen when recorder has some unfixed bugs and the same node is recorded twice. Or something goes wrong when saving or transferring event data.\n   * Duplicated node creation may cause unexpected errors in replayer. This check tries best effort to prevent the errors.\n   */\n  if (mirror.has(n.id)) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const nodeInMirror = mirror.getNode(n.id)!;\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const meta = mirror.getMeta(nodeInMirror)!;\n    // For safety concern, check if the node in mirror is the same as the node we are trying to build\n    if (isNodeMetaEqual(meta, n)) return mirror.getNode(n.id);\n  }\n  let node = buildNode(n, { doc, hackCss, cache });\n  if (!node) {\n    return null;\n  }\n  // If the snapshot is created by checkout, the rootId doesn't change but the iframe's document can be changed automatically when a new iframe element is created.\n  if (n.rootId && (mirror.getNode(n.rootId) as Document) !== doc) {\n    mirror.replace(n.rootId, doc);\n  }\n  // use target document as root document\n  if (n.type === NodeType.Document) {\n    // close before open to make sure document was closed\n    doc.close();\n    doc.open();\n    if (\n      n.compatMode === 'BackCompat' &&\n      n.childNodes &&\n      n.childNodes[0].type !== NodeType.DocumentType // there isn't one already defined\n    ) {\n      // Trigger compatMode in the iframe\n      // this is needed as document.createElement('iframe') otherwise inherits a CSS1Compat mode from the parent replayer environment\n      if (\n        n.childNodes[0].type === NodeType.Element &&\n        'xmlns' in n.childNodes[0].attributes &&\n        n.childNodes[0].attributes.xmlns === 'http://www.w3.org/1999/xhtml'\n      ) {\n        // might as well use an xhtml doctype if we've got an xhtml namespace\n        doc.write(\n          '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\">',\n        );\n      } else {\n        doc.write(\n          '<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\">',\n        );\n      }\n    }\n    node = doc;\n  }\n\n  mirror.add(node, n);\n\n  if (\n    (n.type === NodeType.Document || n.type === NodeType.Element) &&\n    !skipChild\n  ) {\n    for (const childN of n.childNodes) {\n      const childNode = buildNodeWithSN(childN, {\n        doc,\n        mirror,\n        skipChild: false,\n        hackCss,\n        afterAppend,\n        cache,\n      });\n      if (!childNode) {\n        console.warn('Failed to rebuild', childN);\n        continue;\n      }\n\n      if (childN.isShadow && isElement(node) && node.shadowRoot) {\n        node.shadowRoot.appendChild(childNode);\n      } else if (\n        n.type === NodeType.Document &&\n        childN.type == NodeType.Element\n      ) {\n        const htmlElement = childNode as HTMLElement;\n        let body: HTMLBodyElement | null = null;\n        htmlElement.childNodes.forEach((child) => {\n          if (child.nodeName === 'BODY') body = child as HTMLBodyElement;\n        });\n        if (body) {\n          // this branch solves a problem in Firefox where css transitions are incorrectly\n          // being applied upon rebuild.  Presumably FF doesn't finished parsing the styles\n          // in time, and applies e.g. a default margin:0 to elements which have a non-zero\n          // margin set in CSS, along with a transition on them\n          htmlElement.removeChild(body);\n          // append <head> and <style>s\n          node.appendChild(childNode);\n          // now append <body>\n          htmlElement.appendChild(body);\n        } else {\n          node.appendChild(childNode);\n        }\n      } else {\n        node.appendChild(childNode);\n      }\n      if (afterAppend) {\n        afterAppend(childNode, childN.id);\n      }\n    }\n  }\n\n  return node;\n}\n\nfunction visit(mirror: Mirror, onVisit: (node: Node) => void) {\n  function walk(node: Node) {\n    onVisit(node);\n  }\n\n  for (const id of mirror.getIds()) {\n    if (mirror.has(id)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      walk(mirror.getNode(id)!);\n    }\n  }\n}\n\nfunction handleScroll(node: Node, mirror: Mirror) {\n  const n = mirror.getMeta(node);\n  if (n?.type !== NodeType.Element) {\n    return;\n  }\n  const el = node as HTMLElement;\n  for (const name in n.attributes) {\n    if (\n      !(\n        Object.prototype.hasOwnProperty.call(n.attributes, name) &&\n        name.startsWith('rr_')\n      )\n    ) {\n      continue;\n    }\n    const value = n.attributes[name];\n    if (name === 'rr_scrollLeft') {\n      el.scrollLeft = value as number;\n    }\n    if (name === 'rr_scrollTop') {\n      el.scrollTop = value as number;\n    }\n  }\n}\n\nfunction rebuild(\n  n: serializedNodeWithId,\n  options: {\n    doc: Document;\n    onVisit?: (node: Node) => unknown;\n    hackCss?: boolean;\n    afterAppend?: (n: Node, id: number) => unknown;\n    cache: BuildCache;\n    mirror: Mirror;\n  },\n): Node | null {\n  const {\n    doc,\n    onVisit,\n    hackCss = true,\n    afterAppend,\n    cache,\n    mirror = new Mirror(),\n  } = options;\n  const node = buildNodeWithSN(n, {\n    doc,\n    mirror,\n    skipChild: false,\n    hackCss,\n    afterAppend,\n    cache,\n  });\n  visit(mirror, (visitedNode) => {\n    if (onVisit) {\n      onVisit(visitedNode);\n    }\n    handleScroll(visitedNode, mirror);\n  });\n  return node;\n}\n\nexport default rebuild;\n"],
  "mappings": "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",
  "names": ["NodeType", "NodeType2", "isElement", "n", "isShadowRoot", "host", "isNativeShadowDom", "shadowRoot", "fixBrowserCompatibilityIssuesInCSS", "cssText", "escapeImportStatement", "rule", "statement", "stringifyStylesheet", "s", "rules", "stringifyRule", "error", "importStringified", "isCSSImportRule", "isCSSStyleRule", "fixSafariColons", "cssStringified", "regex", "Mirror", "__publicField", "id", "_a", "childNode", "node", "meta", "oldNode", "createMirror", "maskInputValue", "element", "maskInputOptions", "tagName", "type", "value", "maskInputFn", "text", "actualType", "toLowerCase", "str", "ORIGINAL_ATTRIBUTE_NAME", "is2DCanvasBlank", "canvas", "ctx", "chunkSize", "x", "y", "getImageData", "originalGetImageData", "pixel", "isNodeMetaEqual", "a", "b", "getInputType", "extractFileExtension", "path", "baseURL", "url", "err", "match", "_id", "tagNameRegex", "IGNORED_NODE", "genId", "getValidTagName", "processedTagName", "extractOrigin", "origin", "canvasService", "canvasCtx", "URL_IN_CSS_REF", "URL_PROTOCOL_MATCH", "URL_WWW_MATCH", "DATA_URI", "absoluteToStylesheet", "href", "quote1", "path1", "quote2", "path2", "path3", "filePath", "maybeQuote", "stack", "parts", "part", "SRCSET_NOT_SPACES", "SRCSET_COMMAS_OR_SPACES", "getAbsoluteSrcsetString", "doc", "attributeValue", "pos", "collectCharacters", "regEx", "chars", "output", "absoluteToDoc", "descriptorsStr", "inParens", "c", "cachedDocument", "getHref", "isSVGElement", "el", "customHref", "transformAttribute", "name", "ignoreAttribute", "_value", "_isBlockedElement", "blockClass", "blockSelector", "eIndex", "className", "e", "classMatchesRegex", "checkAncestors", "needMaskingText", "maskTextClass", "maskTextSelector", "onceIframeLoaded", "iframeEl", "listener", "iframeLoadTimeout", "win", "fired", "readyState", "timer", "blankUrl", "onceStylesheetLoaded", "link", "styleSheetLoadTimeout", "styleSheetLoaded", "serializeNode", "options", "mirror", "needsMask", "inlineStylesheet", "maskTextFn", "dataURLOptions", "inlineImages", "recordCanvas", "keepIframeSrcFn", "newlyAddedElement", "rootId", "getRootId", "serializeElementNode", "serializeTextNode", "docId", "parentTagName", "textContent", "isStyle", "isScript", "needBlock", "attributes", "len", "i", "attr", "stylesheet", "checked", "canvasDataURL", "blankCanvas", "blankCanvasDataURL", "image", "imageSrc", "priorCrossOrigin", "recordInlineImage", "mediaAttributes", "width", "height", "isCustomElement", "lowerIfExists", "maybeAttr", "slimDOMExcluded", "sn", "slimDOMOptions", "serializeNodeWithId", "skipChild", "onSerialize", "onIframeLoad", "onStylesheetLoad", "stylesheetLoadTimeout", "preserveWhiteSpace", "_serializedNode", "serializedNode", "recordChild", "bypassOptions", "childN", "serializedChildNode", "iframeDoc", "serializedIframeNode", "serializedLinkNode", "snapshot", "maskAllInputs", "slimDOM", "visitSnapshot", "onVisit", "walk", "current", "cleanupSnapshot", "commentre", "parse", "css", "lineno", "column", "updatePosition", "lines", "position", "start", "Position", "whitespace", "_Position", "errorsList", "msg", "rulesList", "open", "close", "comments", "atrule", "re", "m", "comment", "selectorMatcher", "selector", "cleanedInput", "customSplit", "input", "result", "currentSegment", "depthParentheses", "depthBrackets", "currentStringChar", "char", "hasStringEscape", "declaration", "propMatch", "prop", "trim", "val", "ret", "declarations", "decls", "decl", "keyframe", "vals", "atkeyframes", "vendor", "frame", "frames", "atsupports", "supports", "style", "athost", "atmedia", "media", "atcustommedia", "atpage", "sel", "atdocument", "atfontface", "atimport", "_compileAtrule", "atcharset", "atnamespace", "addParent", "obj", "parent", "isNode", "childParent", "k", "v", "tagMap", "getTagName", "escapeRegExp", "MEDIA_SELECTOR", "MEDIA_SELECTOR_GLOBAL", "HOVER_SELECTOR", "HOVER_SELECTOR_GLOBAL", "adaptCssForReplay", "cache", "cachedStyle", "ast", "selectors", "medias", "getSelectors", "index", "newSelector", "mediaMatcher", "createCache", "buildNode", "hackCss", "specialAttributes", "isTextarea", "isRemoteOrDynamicCss", "buildNodeWithSN", "afterAppend", "nodeInMirror", "htmlElement", "body", "child", "visit", "handleScroll", "rebuild", "visitedNode"]
}
