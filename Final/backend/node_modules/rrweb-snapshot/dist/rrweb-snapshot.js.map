{"version":3,"file":"rrweb-snapshot.js","sources":["../src/types.ts","../src/utils.ts","../src/snapshot.ts","../src/css.ts","../src/rebuild.ts"],"sourcesContent":["export enum NodeType {\n  Document,\n  DocumentType,\n  Element,\n  Text,\n  CDATA,\n  Comment,\n}\n\nexport type documentNode = {\n  type: NodeType.Document;\n  childNodes: serializedNodeWithId[];\n  compatMode?: string;\n};\n\nexport type documentTypeNode = {\n  type: NodeType.DocumentType;\n  name: string;\n  publicId: string;\n  systemId: string;\n};\n\nexport type attributes = {\n  [key: string]: string | number | true | null;\n};\nexport type legacyAttributes = {\n  /**\n   * @deprecated old bug in rrweb was causing these to always be set\n   * @see https://github.com/rrweb-io/rrweb/pull/651\n   */\n  selected: false;\n};\n\nexport type elementNode = {\n  type: NodeType.Element;\n  tagName: string;\n  attributes: attributes;\n  childNodes: serializedNodeWithId[];\n  isSVG?: true;\n  needBlock?: boolean;\n  // This is a custom element or not.\n  isCustom?: true;\n};\n\nexport type textNode = {\n  type: NodeType.Text;\n  textContent: string;\n  isStyle?: true;\n};\n\nexport type cdataNode = {\n  type: NodeType.CDATA;\n  textContent: '';\n};\n\nexport type commentNode = {\n  type: NodeType.Comment;\n  textContent: string;\n};\n\nexport type serializedNode = (\n  | documentNode\n  | documentTypeNode\n  | elementNode\n  | textNode\n  | cdataNode\n  | commentNode\n) & {\n  rootId?: number;\n  isShadowHost?: boolean;\n  isShadow?: boolean;\n};\n\nexport type serializedNodeWithId = serializedNode & { id: number };\n\nexport type serializedElementNodeWithId = Extract<\n  serializedNodeWithId,\n  Record<'type', NodeType.Element>\n>;\n\nexport type tagMap = {\n  [key: string]: string;\n};\n\nexport type mediaAttributes = {\n  rr_mediaState: 'played' | 'paused';\n  rr_mediaCurrentTime: number;\n  /**\n   * for backwards compatibility this is optional but should always be set\n   */\n  rr_mediaPlaybackRate?: number;\n  /**\n   * for backwards compatibility this is optional but should always be set\n   */\n  rr_mediaMuted?: boolean;\n  /**\n   * for backwards compatibility this is optional but should always be set\n   */\n  rr_mediaLoop?: boolean;\n  /**\n   * for backwards compatibility this is optional but should always be set\n   */\n  rr_mediaVolume?: number;\n};\n\n// @deprecated\nexport interface INode extends Node {\n  __sn: serializedNodeWithId;\n}\n\nexport interface ICanvas extends HTMLCanvasElement {\n  __context: string;\n}\n\nexport interface IMirror<TNode> {\n  getId(n: TNode | undefined | null): number;\n\n  getNode(id: number): TNode | null;\n\n  getIds(): number[];\n\n  getMeta(n: TNode): serializedNodeWithId | null;\n\n  removeNodeFromMap(n: TNode): void;\n\n  has(id: number): boolean;\n\n  hasNode(node: TNode): boolean;\n\n  add(n: TNode, meta: serializedNodeWithId): void;\n\n  replace(id: number, n: TNode): void;\n\n  reset(): void;\n}\n\nexport type idNodeMap = Map<number, Node>;\n\nexport type nodeMetaMap = WeakMap<Node, serializedNodeWithId>;\n\nexport type MaskInputOptions = Partial<{\n  color: boolean;\n  date: boolean;\n  'datetime-local': boolean;\n  email: boolean;\n  month: boolean;\n  number: boolean;\n  range: boolean;\n  search: boolean;\n  tel: boolean;\n  text: boolean;\n  time: boolean;\n  url: boolean;\n  week: boolean;\n  // unify textarea and select element with text input\n  textarea: boolean;\n  select: boolean;\n  password: boolean;\n}>;\n\nexport type SlimDOMOptions = Partial<{\n  script: boolean;\n  comment: boolean;\n  headFavicon: boolean;\n  headWhitespace: boolean;\n  headMetaDescKeywords: boolean;\n  headMetaSocial: boolean;\n  headMetaRobots: boolean;\n  headMetaHttpEquiv: boolean;\n  headMetaAuthorship: boolean;\n  headMetaVerification: boolean;\n  /**\n   * blocks title tag 'animations' which can generate a lot of mutations that aren't usually displayed in replayers\n   **/\n  headTitleMutations: boolean;\n}>;\n\nexport type DataURLOptions = Partial<{\n  type: string;\n  quality: number;\n}>;\n\nexport type MaskTextFn = (text: string, element: HTMLElement | null) => string;\nexport type MaskInputFn = (text: string, element: HTMLElement) => string;\n\nexport type KeepIframeSrcFn = (src: string) => boolean;\n\nexport type BuildCache = {\n  stylesWithHoverClass: Map<string, string>;\n};\n","import type {\n  idNodeMap,\n  MaskInputFn,\n  MaskInputOptions,\n  nodeMetaMap,\n  IMirror,\n  serializedNodeWithId,\n  serializedNode,\n  documentNode,\n  documentTypeNode,\n  textNode,\n  elementNode,\n} from './types';\nimport { NodeType } from './types';\n\nexport function isElement(n: Node): n is Element {\n  return n.nodeType === n.ELEMENT_NODE;\n}\n\nexport function isShadowRoot(n: Node): n is ShadowRoot {\n  const host: Element | null = (n as ShadowRoot)?.host;\n  return Boolean(host?.shadowRoot === n);\n}\n\n/**\n * To fix the issue https://github.com/rrweb-io/rrweb/issues/933.\n * Some websites use polyfilled shadow dom and this function is used to detect this situation.\n */\nexport function isNativeShadowDom(shadowRoot: ShadowRoot): boolean {\n  return Object.prototype.toString.call(shadowRoot) === '[object ShadowRoot]';\n}\n\n/**\n * Browsers sometimes destructively modify the css rules they receive.\n * This function tries to rectify the modifications the browser made to make it more cross platform compatible.\n * @param cssText - output of `CSSStyleRule.cssText`\n * @returns `cssText` with browser inconsistencies fixed.\n */\nfunction fixBrowserCompatibilityIssuesInCSS(cssText: string): string {\n  /**\n   * Chrome outputs `-webkit-background-clip` as `background-clip` in `CSSStyleRule.cssText`.\n   * But then Chrome ignores `background-clip` as css input.\n   * Re-introduce `-webkit-background-clip` to fix this issue.\n   */\n  if (\n    cssText.includes(' background-clip: text;') &&\n    !cssText.includes(' -webkit-background-clip: text;')\n  ) {\n    cssText = cssText.replace(\n      /\\sbackground-clip:\\s*text;/g,\n      ' -webkit-background-clip: text; background-clip: text;',\n    );\n  }\n  return cssText;\n}\n\n// Remove this declaration once typescript has added `CSSImportRule.supportsText` to the lib.\ndeclare interface CSSImportRule extends CSSRule {\n  readonly href: string;\n  readonly layerName: string | null;\n  readonly media: MediaList;\n  readonly styleSheet: CSSStyleSheet;\n  /**\n   * experimental API, currently only supported in firefox\n   * https://developer.mozilla.org/en-US/docs/Web/API/CSSImportRule/supportsText\n   */\n  readonly supportsText?: string | null;\n}\n\n/**\n * Browsers sometimes incorrectly escape `@import` on `.cssText` statements.\n * This function tries to correct the escaping.\n * more info: https://bugs.chromium.org/p/chromium/issues/detail?id=1472259\n * @param cssImportRule\n * @returns `cssText` with browser inconsistencies fixed, or null if not applicable.\n */\nexport function escapeImportStatement(rule: CSSImportRule): string {\n  const { cssText } = rule;\n  if (cssText.split('\"').length < 3) return cssText;\n\n  const statement = ['@import', `url(${JSON.stringify(rule.href)})`];\n  if (rule.layerName === '') {\n    statement.push(`layer`);\n  } else if (rule.layerName) {\n    statement.push(`layer(${rule.layerName})`);\n  }\n  if (rule.supportsText) {\n    statement.push(`supports(${rule.supportsText})`);\n  }\n  if (rule.media.length) {\n    statement.push(rule.media.mediaText);\n  }\n  return statement.join(' ') + ';';\n}\n\nexport function stringifyStylesheet(s: CSSStyleSheet): string | null {\n  try {\n    const rules = s.rules || s.cssRules;\n    return rules\n      ? fixBrowserCompatibilityIssuesInCSS(\n          Array.from(rules, stringifyRule).join(''),\n        )\n      : null;\n  } catch (error) {\n    return null;\n  }\n}\n\nexport function stringifyRule(rule: CSSRule): string {\n  let importStringified;\n  if (isCSSImportRule(rule)) {\n    try {\n      importStringified =\n        // for same-origin stylesheets,\n        // we can access the imported stylesheet rules directly\n        stringifyStylesheet(rule.styleSheet) ||\n        // work around browser issues with the raw string `@import url(...)` statement\n        escapeImportStatement(rule);\n    } catch (error) {\n      // ignore\n    }\n  } else if (isCSSStyleRule(rule) && rule.selectorText.includes(':')) {\n    // Safari does not escape selectors with : properly\n    // see https://bugs.webkit.org/show_bug.cgi?id=184604\n    return fixSafariColons(rule.cssText);\n  }\n\n  return importStringified || rule.cssText;\n}\n\nexport function fixSafariColons(cssStringified: string): string {\n  // Replace e.g. [aa:bb] with [aa\\\\:bb]\n  const regex = /(\\[(?:[\\w-]+)[^\\\\])(:(?:[\\w-]+)\\])/gm;\n  return cssStringified.replace(regex, '$1\\\\$2');\n}\n\nexport function isCSSImportRule(rule: CSSRule): rule is CSSImportRule {\n  return 'styleSheet' in rule;\n}\n\nexport function isCSSStyleRule(rule: CSSRule): rule is CSSStyleRule {\n  return 'selectorText' in rule;\n}\n\nexport class Mirror implements IMirror<Node> {\n  private idNodeMap: idNodeMap = new Map();\n  private nodeMetaMap: nodeMetaMap = new WeakMap();\n\n  getId(n: Node | undefined | null): number {\n    if (!n) return -1;\n\n    const id = this.getMeta(n)?.id;\n\n    // if n is not a serialized Node, use -1 as its id.\n    return id ?? -1;\n  }\n\n  getNode(id: number): Node | null {\n    return this.idNodeMap.get(id) || null;\n  }\n\n  getIds(): number[] {\n    return Array.from(this.idNodeMap.keys());\n  }\n\n  getMeta(n: Node): serializedNodeWithId | null {\n    return this.nodeMetaMap.get(n) || null;\n  }\n\n  // removes the node from idNodeMap\n  // doesn't remove the node from nodeMetaMap\n  removeNodeFromMap(n: Node) {\n    const id = this.getId(n);\n    this.idNodeMap.delete(id);\n\n    if (n.childNodes) {\n      n.childNodes.forEach((childNode) =>\n        this.removeNodeFromMap(childNode as unknown as Node),\n      );\n    }\n  }\n  has(id: number): boolean {\n    return this.idNodeMap.has(id);\n  }\n\n  hasNode(node: Node): boolean {\n    return this.nodeMetaMap.has(node);\n  }\n\n  add(n: Node, meta: serializedNodeWithId) {\n    const id = meta.id;\n    this.idNodeMap.set(id, n);\n    this.nodeMetaMap.set(n, meta);\n  }\n\n  replace(id: number, n: Node) {\n    const oldNode = this.getNode(id);\n    if (oldNode) {\n      const meta = this.nodeMetaMap.get(oldNode);\n      if (meta) this.nodeMetaMap.set(n, meta);\n    }\n    this.idNodeMap.set(id, n);\n  }\n\n  reset() {\n    this.idNodeMap = new Map();\n    this.nodeMetaMap = new WeakMap();\n  }\n}\n\nexport function createMirror(): Mirror {\n  return new Mirror();\n}\n\nexport function maskInputValue({\n  element,\n  maskInputOptions,\n  tagName,\n  type,\n  value,\n  maskInputFn,\n}: {\n  element: HTMLElement;\n  maskInputOptions: MaskInputOptions;\n  tagName: string;\n  type: string | null;\n  value: string | null;\n  maskInputFn?: MaskInputFn;\n}): string {\n  let text = value || '';\n  const actualType = type && toLowerCase(type);\n\n  if (\n    maskInputOptions[tagName.toLowerCase() as keyof MaskInputOptions] ||\n    (actualType && maskInputOptions[actualType as keyof MaskInputOptions])\n  ) {\n    if (maskInputFn) {\n      text = maskInputFn(text, element);\n    } else {\n      text = '*'.repeat(text.length);\n    }\n  }\n  return text;\n}\n\nexport function toLowerCase<T extends string>(str: T): Lowercase<T> {\n  return str.toLowerCase() as unknown as Lowercase<T>;\n}\n\nconst ORIGINAL_ATTRIBUTE_NAME = '__rrweb_original__';\ntype PatchedGetImageData = {\n  [ORIGINAL_ATTRIBUTE_NAME]: CanvasImageData['getImageData'];\n} & CanvasImageData['getImageData'];\n\nexport function is2DCanvasBlank(canvas: HTMLCanvasElement): boolean {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) return true;\n\n  const chunkSize = 50;\n\n  // get chunks of the canvas and check if it is blank\n  for (let x = 0; x < canvas.width; x += chunkSize) {\n    for (let y = 0; y < canvas.height; y += chunkSize) {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const getImageData = ctx.getImageData as PatchedGetImageData;\n      const originalGetImageData =\n        ORIGINAL_ATTRIBUTE_NAME in getImageData\n          ? getImageData[ORIGINAL_ATTRIBUTE_NAME]\n          : getImageData;\n      // by getting the canvas in chunks we avoid an expensive\n      // `getImageData` call that retrieves everything\n      // even if we can already tell from the first chunk(s) that\n      // the canvas isn't blank\n      const pixelBuffer = new Uint32Array(\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access\n        originalGetImageData.call(\n          ctx,\n          x,\n          y,\n          Math.min(chunkSize, canvas.width - x),\n          Math.min(chunkSize, canvas.height - y),\n        ).data.buffer,\n      );\n      if (pixelBuffer.some((pixel) => pixel !== 0)) return false;\n    }\n  }\n  return true;\n}\n\nexport function isNodeMetaEqual(a: serializedNode, b: serializedNode): boolean {\n  if (!a || !b || a.type !== b.type) return false;\n  if (a.type === NodeType.Document)\n    return a.compatMode === (b as documentNode).compatMode;\n  else if (a.type === NodeType.DocumentType)\n    return (\n      a.name === (b as documentTypeNode).name &&\n      a.publicId === (b as documentTypeNode).publicId &&\n      a.systemId === (b as documentTypeNode).systemId\n    );\n  else if (\n    a.type === NodeType.Comment ||\n    a.type === NodeType.Text ||\n    a.type === NodeType.CDATA\n  )\n    return a.textContent === (b as textNode).textContent;\n  else if (a.type === NodeType.Element)\n    return (\n      a.tagName === (b as elementNode).tagName &&\n      JSON.stringify(a.attributes) ===\n        JSON.stringify((b as elementNode).attributes) &&\n      a.isSVG === (b as elementNode).isSVG &&\n      a.needBlock === (b as elementNode).needBlock\n    );\n  return false;\n}\n\n/**\n * Get the type of an input element.\n * This takes care of the case where a password input is changed to a text input.\n * In this case, we continue to consider this of type password, in order to avoid leaking sensitive data\n * where passwords should be masked.\n */\nexport function getInputType(element: HTMLElement): Lowercase<string> | null {\n  // when omitting the type of input element(e.g. <input />), the type is treated as text\n  const type = (element as HTMLInputElement).type;\n\n  return element.hasAttribute('data-rr-is-password')\n    ? 'password'\n    : type\n    ? // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n      toLowerCase(type)\n    : null;\n}\n\n/**\n * Extracts the file extension from an a path, considering search parameters and fragments.\n * @param path - Path to file\n * @param baseURL - [optional] Base URL of the page, used to resolve relative paths. Defaults to current page URL.\n */\nexport function extractFileExtension(\n  path: string,\n  baseURL?: string,\n): string | null {\n  let url;\n  try {\n    url = new URL(path, baseURL ?? window.location.href);\n  } catch (err) {\n    return null;\n  }\n  const regex = /\\.([0-9a-z]+)(?:$)/i;\n  const match = url.pathname.match(regex);\n  return match?.[1] ?? null;\n}\n","import {\n  type serializedNode,\n  type serializedNodeWithId,\n  NodeType,\n  type attributes,\n  type MaskInputOptions,\n  type SlimDOMOptions,\n  type DataURLOptions,\n  type MaskTextFn,\n  type MaskInputFn,\n  type KeepIframeSrcFn,\n  type ICanvas,\n  type elementNode,\n  type serializedElementNodeWithId,\n  type mediaAttributes,\n} from './types';\nimport {\n  Mirror,\n  is2DCanvasBlank,\n  isElement,\n  isShadowRoot,\n  maskInputValue,\n  isNativeShadowDom,\n  stringifyStylesheet,\n  getInputType,\n  toLowerCase,\n  extractFileExtension,\n} from './utils';\n\nlet _id = 1;\nconst tagNameRegex = new RegExp('[^a-z0-9-_:]');\n\nexport const IGNORED_NODE = -2;\n\nexport function genId(): number {\n  return _id++;\n}\n\nfunction getValidTagName(element: HTMLElement): Lowercase<string> {\n  if (element instanceof HTMLFormElement) {\n    return 'form';\n  }\n\n  const processedTagName = toLowerCase(element.tagName);\n\n  if (tagNameRegex.test(processedTagName)) {\n    // if the tag name is odd and we cannot extract\n    // anything from the string, then we return a\n    // generic div\n    return 'div';\n  }\n\n  return processedTagName;\n}\n\nfunction extractOrigin(url: string): string {\n  let origin = '';\n  if (url.indexOf('//') > -1) {\n    origin = url.split('/').slice(0, 3).join('/');\n  } else {\n    origin = url.split('/')[0];\n  }\n  origin = origin.split('?')[0];\n  return origin;\n}\n\nlet canvasService: HTMLCanvasElement | null;\nlet canvasCtx: CanvasRenderingContext2D | null;\n\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\nconst URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\\/\\//i;\nconst URL_WWW_MATCH = /^www\\..*/i;\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\nexport function absoluteToStylesheet(\n  cssText: string | null,\n  href: string,\n): string {\n  return (cssText || '').replace(\n    URL_IN_CSS_REF,\n    (\n      origin: string,\n      quote1: string,\n      path1: string,\n      quote2: string,\n      path2: string,\n      path3: string,\n    ) => {\n      const filePath = path1 || path2 || path3;\n      const maybeQuote = quote1 || quote2 || '';\n      if (!filePath) {\n        return origin;\n      }\n      if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (DATA_URI.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (filePath[0] === '/') {\n        return `url(${maybeQuote}${\n          extractOrigin(href) + filePath\n        }${maybeQuote})`;\n      }\n      const stack = href.split('/');\n      const parts = filePath.split('/');\n      stack.pop();\n      for (const part of parts) {\n        if (part === '.') {\n          continue;\n        } else if (part === '..') {\n          stack.pop();\n        } else {\n          stack.push(part);\n        }\n      }\n      return `url(${maybeQuote}${stack.join('/')}${maybeQuote})`;\n    },\n  );\n}\n\n// eslint-disable-next-line no-control-regex\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/; // Don't use \\s, to avoid matching non-breaking space\n// eslint-disable-next-line no-control-regex\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\nfunction getAbsoluteSrcsetString(doc: Document, attributeValue: string) {\n  /*\n    run absoluteToDoc over every url in the srcset\n\n    this is adapted from https://github.com/albell/parse-srcset/\n    without the parsing of the descriptors (we return these as-is)\n    parce-srcset is in turn based on\n    https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-srcset-attribute\n  */\n  if (attributeValue.trim() === '') {\n    return attributeValue;\n  }\n\n  let pos = 0;\n\n  function collectCharacters(regEx: RegExp) {\n    let chars: string;\n    const match = regEx.exec(attributeValue.substring(pos));\n    if (match) {\n      chars = match[0];\n      pos += chars.length;\n      return chars;\n    }\n    return '';\n  }\n\n  const output = [];\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    collectCharacters(SRCSET_COMMAS_OR_SPACES);\n    if (pos >= attributeValue.length) {\n      break;\n    }\n    // don't split on commas within urls\n    let url = collectCharacters(SRCSET_NOT_SPACES);\n    if (url.slice(-1) === ',') {\n      // aside: according to spec more than one comma at the end is a parse error, but we ignore that\n      url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n      // the trailing comma splits the srcset, so the interpretion is that\n      // another url will follow, and the descriptor is empty\n      output.push(url);\n    } else {\n      let descriptorsStr = '';\n      url = absoluteToDoc(doc, url);\n      let inParens = false;\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        const c = attributeValue.charAt(pos);\n        if (c === '') {\n          output.push((url + descriptorsStr).trim());\n          break;\n        } else if (!inParens) {\n          if (c === ',') {\n            pos += 1;\n            output.push((url + descriptorsStr).trim());\n            break; // parse the next url\n          } else if (c === '(') {\n            inParens = true;\n          }\n        } else {\n          // in parenthesis; ignore commas\n          // (parenthesis may be supported by future additions to spec)\n          if (c === ')') {\n            inParens = false;\n          }\n        }\n        descriptorsStr += c;\n        pos += 1;\n      }\n    }\n  }\n  return output.join(', ');\n}\n\nconst cachedDocument = new WeakMap<Document, HTMLAnchorElement>();\n\nexport function absoluteToDoc(doc: Document, attributeValue: string): string {\n  if (!attributeValue || attributeValue.trim() === '') {\n    return attributeValue;\n  }\n\n  return getHref(doc, attributeValue);\n}\n\nfunction isSVGElement(el: Element): boolean {\n  return Boolean(el.tagName === 'svg' || (el as SVGElement).ownerSVGElement);\n}\n\nfunction getHref(doc: Document, customHref?: string) {\n  let a = cachedDocument.get(doc);\n  if (!a) {\n    a = doc.createElement('a');\n    cachedDocument.set(doc, a);\n  }\n  if (!customHref) {\n    customHref = '';\n  } else if (customHref.startsWith('blob:') || customHref.startsWith('data:')) {\n    return customHref;\n  }\n  // note: using `new URL` is slower. See #1434 or https://jsbench.me/uqlud17rxo/1\n  a.setAttribute('href', customHref);\n  return a.href;\n}\n\nexport function transformAttribute(\n  doc: Document,\n  tagName: Lowercase<string>,\n  name: Lowercase<string>,\n  value: string | null,\n): string | null {\n  if (!value) {\n    return value;\n  }\n\n  // relative path in attribute\n  if (\n    name === 'src' ||\n    (name === 'href' && !(tagName === 'use' && value[0] === '#'))\n  ) {\n    // href starts with a # is an id pointer for svg\n    return absoluteToDoc(doc, value);\n  } else if (name === 'xlink:href' && value[0] !== '#') {\n    // xlink:href starts with # is an id pointer\n    return absoluteToDoc(doc, value);\n  } else if (\n    name === 'background' &&\n    (tagName === 'table' || tagName === 'td' || tagName === 'th')\n  ) {\n    return absoluteToDoc(doc, value);\n  } else if (name === 'srcset') {\n    return getAbsoluteSrcsetString(doc, value);\n  } else if (name === 'style') {\n    return absoluteToStylesheet(value, getHref(doc));\n  } else if (tagName === 'object' && name === 'data') {\n    return absoluteToDoc(doc, value);\n  }\n\n  return value;\n}\n\nexport function ignoreAttribute(\n  tagName: string,\n  name: string,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _value: unknown,\n): boolean {\n  return (tagName === 'video' || tagName === 'audio') && name === 'autoplay';\n}\n\nexport function _isBlockedElement(\n  element: HTMLElement,\n  blockClass: string | RegExp,\n  blockSelector: string | null,\n): boolean {\n  try {\n    if (typeof blockClass === 'string') {\n      if (element.classList.contains(blockClass)) {\n        return true;\n      }\n    } else {\n      for (let eIndex = element.classList.length; eIndex--; ) {\n        const className = element.classList[eIndex];\n        if (blockClass.test(className)) {\n          return true;\n        }\n      }\n    }\n    if (blockSelector) {\n      return element.matches(blockSelector);\n    }\n  } catch (e) {\n    //\n  }\n\n  return false;\n}\n\nexport function classMatchesRegex(\n  node: Node | null,\n  regex: RegExp,\n  checkAncestors: boolean,\n): boolean {\n  if (!node) return false;\n  if (node.nodeType !== node.ELEMENT_NODE) {\n    if (!checkAncestors) return false;\n    return classMatchesRegex(node.parentNode, regex, checkAncestors);\n  }\n\n  for (let eIndex = (node as HTMLElement).classList.length; eIndex--; ) {\n    const className = (node as HTMLElement).classList[eIndex];\n    if (regex.test(className)) {\n      return true;\n    }\n  }\n  if (!checkAncestors) return false;\n  return classMatchesRegex(node.parentNode, regex, checkAncestors);\n}\n\nexport function needMaskingText(\n  node: Node,\n  maskTextClass: string | RegExp,\n  maskTextSelector: string | null,\n  checkAncestors: boolean,\n): boolean {\n  let el: Element;\n  if (isElement(node)) {\n    el = node;\n    if (!el.childNodes.length) {\n      // optimisation: we can avoid any of the below checks on leaf elements\n      // as masking is applied to child text nodes only\n      return false;\n    }\n  } else if (node.parentElement === null) {\n    // should warn? maybe a text node isn't attached to a parent node yet?\n    return false;\n  } else {\n    el = node.parentElement;\n  }\n  try {\n    if (typeof maskTextClass === 'string') {\n      if (checkAncestors) {\n        if (el.closest(`.${maskTextClass}`)) return true;\n      } else {\n        if (el.classList.contains(maskTextClass)) return true;\n      }\n    } else {\n      if (classMatchesRegex(el, maskTextClass, checkAncestors)) return true;\n    }\n    if (maskTextSelector) {\n      if (checkAncestors) {\n        if (el.closest(maskTextSelector)) return true;\n      } else {\n        if (el.matches(maskTextSelector)) return true;\n      }\n    }\n  } catch (e) {\n    //\n  }\n  return false;\n}\n\n// https://stackoverflow.com/a/36155560\nfunction onceIframeLoaded(\n  iframeEl: HTMLIFrameElement,\n  listener: () => unknown,\n  iframeLoadTimeout: number,\n) {\n  const win = iframeEl.contentWindow;\n  if (!win) {\n    return;\n  }\n  // document is loading\n  let fired = false;\n\n  let readyState: DocumentReadyState;\n  try {\n    readyState = win.document.readyState;\n  } catch (error) {\n    return;\n  }\n  if (readyState !== 'complete') {\n    const timer = setTimeout(() => {\n      if (!fired) {\n        listener();\n        fired = true;\n      }\n    }, iframeLoadTimeout);\n    iframeEl.addEventListener('load', () => {\n      clearTimeout(timer);\n      fired = true;\n      listener();\n    });\n    return;\n  }\n  // check blank frame for Chrome\n  const blankUrl = 'about:blank';\n  if (\n    win.location.href !== blankUrl ||\n    iframeEl.src === blankUrl ||\n    iframeEl.src === ''\n  ) {\n    // iframe was already loaded, make sure we wait to trigger the listener\n    // till _after_ the mutation that found this iframe has had time to process\n    setTimeout(listener, 0);\n\n    return iframeEl.addEventListener('load', listener); // keep listing for future loads\n  }\n  // use default listener\n  iframeEl.addEventListener('load', listener);\n}\n\nfunction onceStylesheetLoaded(\n  link: HTMLLinkElement,\n  listener: () => unknown,\n  styleSheetLoadTimeout: number,\n) {\n  let fired = false;\n  let styleSheetLoaded: StyleSheet | null;\n  try {\n    styleSheetLoaded = link.sheet;\n  } catch (error) {\n    return;\n  }\n\n  if (styleSheetLoaded) return;\n\n  const timer = setTimeout(() => {\n    if (!fired) {\n      listener();\n      fired = true;\n    }\n  }, styleSheetLoadTimeout);\n\n  link.addEventListener('load', () => {\n    clearTimeout(timer);\n    fired = true;\n    listener();\n  });\n}\n\nfunction serializeNode(\n  n: Node,\n  options: {\n    doc: Document;\n    mirror: Mirror;\n    blockClass: string | RegExp;\n    blockSelector: string | null;\n    needsMask: boolean;\n    inlineStylesheet: boolean;\n    maskInputOptions: MaskInputOptions;\n    maskTextFn: MaskTextFn | undefined;\n    maskInputFn: MaskInputFn | undefined;\n    dataURLOptions?: DataURLOptions;\n    inlineImages: boolean;\n    recordCanvas: boolean;\n    keepIframeSrcFn: KeepIframeSrcFn;\n    /**\n     * `newlyAddedElement: true` skips scrollTop and scrollLeft check\n     */\n    newlyAddedElement?: boolean;\n  },\n): serializedNode | false {\n  const {\n    doc,\n    mirror,\n    blockClass,\n    blockSelector,\n    needsMask,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions = {},\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement = false,\n  } = options;\n  // Only record root id when document object is not the base document\n  const rootId = getRootId(doc, mirror);\n  switch (n.nodeType) {\n    case n.DOCUMENT_NODE:\n      if ((n as Document).compatMode !== 'CSS1Compat') {\n        return {\n          type: NodeType.Document,\n          childNodes: [],\n          compatMode: (n as Document).compatMode, // probably \"BackCompat\"\n        };\n      } else {\n        return {\n          type: NodeType.Document,\n          childNodes: [],\n        };\n      }\n    case n.DOCUMENT_TYPE_NODE:\n      return {\n        type: NodeType.DocumentType,\n        name: (n as DocumentType).name,\n        publicId: (n as DocumentType).publicId,\n        systemId: (n as DocumentType).systemId,\n        rootId,\n      };\n    case n.ELEMENT_NODE:\n      return serializeElementNode(n as HTMLElement, {\n        doc,\n        blockClass,\n        blockSelector,\n        inlineStylesheet,\n        maskInputOptions,\n        maskInputFn,\n        dataURLOptions,\n        inlineImages,\n        recordCanvas,\n        keepIframeSrcFn,\n        newlyAddedElement,\n        rootId,\n      });\n    case n.TEXT_NODE:\n      return serializeTextNode(n as Text, {\n        doc,\n        needsMask,\n        maskTextFn,\n        rootId,\n      });\n    case n.CDATA_SECTION_NODE:\n      return {\n        type: NodeType.CDATA,\n        textContent: '',\n        rootId,\n      };\n    case n.COMMENT_NODE:\n      return {\n        type: NodeType.Comment,\n        textContent: (n as Comment).textContent || '',\n        rootId,\n      };\n    default:\n      return false;\n  }\n}\n\nfunction getRootId(doc: Document, mirror: Mirror): number | undefined {\n  if (!mirror.hasNode(doc)) return undefined;\n  const docId = mirror.getId(doc);\n  return docId === 1 ? undefined : docId;\n}\n\nfunction serializeTextNode(\n  n: Text,\n  options: {\n    doc: Document;\n    needsMask: boolean;\n    maskTextFn: MaskTextFn | undefined;\n    rootId: number | undefined;\n  },\n): serializedNode {\n  const { needsMask, maskTextFn, rootId } = options;\n  // The parent node may not be a html element which has a tagName attribute.\n  // So just let it be undefined which is ok in this use case.\n  const parentTagName = n.parentNode && (n.parentNode as HTMLElement).tagName;\n  let textContent = n.textContent;\n  const isStyle = parentTagName === 'STYLE' ? true : undefined;\n  const isScript = parentTagName === 'SCRIPT' ? true : undefined;\n  if (isStyle && textContent) {\n    try {\n      // try to read style sheet\n      if (n.nextSibling || n.previousSibling) {\n        // This is not the only child of the stylesheet.\n        // We can't read all of the sheet's .cssRules and expect them\n        // to _only_ include the current rule(s) added by the text node.\n        // So we'll be conservative and keep textContent as-is.\n      } else if ((n.parentNode as HTMLStyleElement).sheet?.cssRules) {\n        textContent = stringifyStylesheet(\n          (n.parentNode as HTMLStyleElement).sheet!,\n        );\n      }\n    } catch (err) {\n      console.warn(\n        `Cannot get CSS styles from text's parentNode. Error: ${err as string}`,\n        n,\n      );\n    }\n    textContent = absoluteToStylesheet(textContent, getHref(options.doc));\n  }\n  if (isScript) {\n    textContent = 'SCRIPT_PLACEHOLDER';\n  }\n  if (!isStyle && !isScript && textContent && needsMask) {\n    textContent = maskTextFn\n      ? maskTextFn(textContent, n.parentElement)\n      : textContent.replace(/[\\S]/g, '*');\n  }\n\n  return {\n    type: NodeType.Text,\n    textContent: textContent || '',\n    isStyle,\n    rootId,\n  };\n}\n\nfunction serializeElementNode(\n  n: HTMLElement,\n  options: {\n    doc: Document;\n    blockClass: string | RegExp;\n    blockSelector: string | null;\n    inlineStylesheet: boolean;\n    maskInputOptions: MaskInputOptions;\n    maskInputFn: MaskInputFn | undefined;\n    dataURLOptions?: DataURLOptions;\n    inlineImages: boolean;\n    recordCanvas: boolean;\n    keepIframeSrcFn: KeepIframeSrcFn;\n    /**\n     * `newlyAddedElement: true` skips scrollTop and scrollLeft check\n     */\n    newlyAddedElement?: boolean;\n    rootId: number | undefined;\n  },\n): serializedNode | false {\n  const {\n    doc,\n    blockClass,\n    blockSelector,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskInputFn,\n    dataURLOptions = {},\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement = false,\n    rootId,\n  } = options;\n  const needBlock = _isBlockedElement(n, blockClass, blockSelector);\n  const tagName = getValidTagName(n);\n  let attributes: attributes = {};\n  const len = n.attributes.length;\n  for (let i = 0; i < len; i++) {\n    const attr = n.attributes[i];\n    if (!ignoreAttribute(tagName, attr.name, attr.value)) {\n      attributes[attr.name] = transformAttribute(\n        doc,\n        tagName,\n        toLowerCase(attr.name),\n        attr.value,\n      );\n    }\n  }\n  // remote css\n  if (tagName === 'link' && inlineStylesheet) {\n    const stylesheet = Array.from(doc.styleSheets).find((s) => {\n      return s.href === (n as HTMLLinkElement).href;\n    });\n    let cssText: string | null = null;\n    if (stylesheet) {\n      cssText = stringifyStylesheet(stylesheet);\n    }\n    if (cssText) {\n      delete attributes.rel;\n      delete attributes.href;\n      attributes._cssText = absoluteToStylesheet(cssText, stylesheet!.href!);\n    }\n  }\n  // dynamic stylesheet\n  if (\n    tagName === 'style' &&\n    (n as HTMLStyleElement).sheet &&\n    // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n    !(n.innerText || n.textContent || '').trim().length\n  ) {\n    const cssText = stringifyStylesheet(\n      (n as HTMLStyleElement).sheet as CSSStyleSheet,\n    );\n    if (cssText) {\n      attributes._cssText = absoluteToStylesheet(cssText, getHref(doc));\n    }\n  }\n  // form fields\n  if (tagName === 'input' || tagName === 'textarea' || tagName === 'select') {\n    const value = (n as HTMLInputElement | HTMLTextAreaElement).value;\n    const checked = (n as HTMLInputElement).checked;\n    if (\n      attributes.type !== 'radio' &&\n      attributes.type !== 'checkbox' &&\n      attributes.type !== 'submit' &&\n      attributes.type !== 'button' &&\n      value\n    ) {\n      attributes.value = maskInputValue({\n        element: n,\n        type: getInputType(n),\n        tagName,\n        value,\n        maskInputOptions,\n        maskInputFn,\n      });\n    } else if (checked) {\n      attributes.checked = checked;\n    }\n  }\n  if (tagName === 'option') {\n    if ((n as HTMLOptionElement).selected && !maskInputOptions['select']) {\n      attributes.selected = true;\n    } else {\n      // ignore the html attribute (which corresponds to DOM (n as HTMLOptionElement).defaultSelected)\n      // if it's already been changed\n      delete attributes.selected;\n    }\n  }\n  // canvas image data\n  if (tagName === 'canvas' && recordCanvas) {\n    if ((n as ICanvas).__context === '2d') {\n      // only record this on 2d canvas\n      if (!is2DCanvasBlank(n as HTMLCanvasElement)) {\n        attributes.rr_dataURL = (n as HTMLCanvasElement).toDataURL(\n          dataURLOptions.type,\n          dataURLOptions.quality,\n        );\n      }\n    } else if (!('__context' in n)) {\n      // context is unknown, better not call getContext to trigger it\n      const canvasDataURL = (n as HTMLCanvasElement).toDataURL(\n        dataURLOptions.type,\n        dataURLOptions.quality,\n      );\n\n      // create blank canvas of same dimensions\n      const blankCanvas = doc.createElement('canvas');\n      blankCanvas.width = (n as HTMLCanvasElement).width;\n      blankCanvas.height = (n as HTMLCanvasElement).height;\n      const blankCanvasDataURL = blankCanvas.toDataURL(\n        dataURLOptions.type,\n        dataURLOptions.quality,\n      );\n\n      // no need to save dataURL if it's the same as blank canvas\n      if (canvasDataURL !== blankCanvasDataURL) {\n        attributes.rr_dataURL = canvasDataURL;\n      }\n    }\n  }\n  // save image offline\n  if (tagName === 'img' && inlineImages) {\n    if (!canvasService) {\n      canvasService = doc.createElement('canvas');\n      canvasCtx = canvasService.getContext('2d');\n    }\n    const image = n as HTMLImageElement;\n    const imageSrc: string =\n      image.currentSrc || image.getAttribute('src') || '<unknown-src>';\n    const priorCrossOrigin = image.crossOrigin;\n    const recordInlineImage = () => {\n      image.removeEventListener('load', recordInlineImage);\n      try {\n        canvasService!.width = image.naturalWidth;\n        canvasService!.height = image.naturalHeight;\n        canvasCtx!.drawImage(image, 0, 0);\n        attributes.rr_dataURL = canvasService!.toDataURL(\n          dataURLOptions.type,\n          dataURLOptions.quality,\n        );\n      } catch (err) {\n        if (image.crossOrigin !== 'anonymous') {\n          image.crossOrigin = 'anonymous';\n          if (image.complete && image.naturalWidth !== 0)\n            recordInlineImage(); // too early due to image reload\n          else image.addEventListener('load', recordInlineImage);\n          return;\n        } else {\n          console.warn(\n            `Cannot inline img src=${imageSrc}! Error: ${err as string}`,\n          );\n        }\n      }\n      if (image.crossOrigin === 'anonymous') {\n        priorCrossOrigin\n          ? (attributes.crossOrigin = priorCrossOrigin)\n          : image.removeAttribute('crossorigin');\n      }\n    };\n    // The image content may not have finished loading yet.\n    if (image.complete && image.naturalWidth !== 0) recordInlineImage();\n    else image.addEventListener('load', recordInlineImage);\n  }\n  // media elements\n  if (tagName === 'audio' || tagName === 'video') {\n    const mediaAttributes = attributes as mediaAttributes;\n    mediaAttributes.rr_mediaState = (n as HTMLMediaElement).paused\n      ? 'paused'\n      : 'played';\n    mediaAttributes.rr_mediaCurrentTime = (n as HTMLMediaElement).currentTime;\n    mediaAttributes.rr_mediaPlaybackRate = (n as HTMLMediaElement).playbackRate;\n    mediaAttributes.rr_mediaMuted = (n as HTMLMediaElement).muted;\n    mediaAttributes.rr_mediaLoop = (n as HTMLMediaElement).loop;\n    mediaAttributes.rr_mediaVolume = (n as HTMLMediaElement).volume;\n  }\n  // Scroll\n  if (!newlyAddedElement) {\n    // `scrollTop` and `scrollLeft` are expensive calls because they trigger reflow.\n    // Since `scrollTop` & `scrollLeft` are always 0 when an element is added to the DOM.\n    // And scrolls also get picked up by rrweb's ScrollObserver\n    // So we can safely skip the `scrollTop/Left` calls for newly added elements\n    if (n.scrollLeft) {\n      attributes.rr_scrollLeft = n.scrollLeft;\n    }\n    if (n.scrollTop) {\n      attributes.rr_scrollTop = n.scrollTop;\n    }\n  }\n  // block element\n  if (needBlock) {\n    const { width, height } = n.getBoundingClientRect();\n    attributes = {\n      class: attributes.class,\n      rr_width: `${width}px`,\n      rr_height: `${height}px`,\n    };\n  }\n  // iframe\n  if (tagName === 'iframe' && !keepIframeSrcFn(attributes.src as string)) {\n    if (!(n as HTMLIFrameElement).contentDocument) {\n      // we can't record it directly as we can't see into it\n      // preserve the src attribute so a decision can be taken at replay time\n      attributes.rr_src = attributes.src;\n    }\n    delete attributes.src; // prevent auto loading\n  }\n\n  let isCustomElement: true | undefined;\n  try {\n    if (customElements.get(tagName)) isCustomElement = true;\n  } catch (e) {\n    // In case old browsers don't support customElements\n  }\n\n  return {\n    type: NodeType.Element,\n    tagName,\n    attributes,\n    childNodes: [],\n    isSVG: isSVGElement(n as Element) || undefined,\n    needBlock,\n    rootId,\n    isCustom: isCustomElement,\n  };\n}\n\nfunction lowerIfExists(\n  maybeAttr: string | number | boolean | undefined | null,\n): string {\n  if (maybeAttr === undefined || maybeAttr === null) {\n    return '';\n  } else {\n    return (maybeAttr as string).toLowerCase();\n  }\n}\n\nfunction slimDOMExcluded(\n  sn: serializedNode,\n  slimDOMOptions: SlimDOMOptions,\n): boolean {\n  if (slimDOMOptions.comment && sn.type === NodeType.Comment) {\n    // TODO: convert IE conditional comments to real nodes\n    return true;\n  } else if (sn.type === NodeType.Element) {\n    if (\n      slimDOMOptions.script &&\n      // script tag\n      (sn.tagName === 'script' ||\n        // (module)preload link\n        (sn.tagName === 'link' &&\n          (sn.attributes.rel === 'preload' ||\n            sn.attributes.rel === 'modulepreload') &&\n          sn.attributes.as === 'script') ||\n        // prefetch link\n        (sn.tagName === 'link' &&\n          sn.attributes.rel === 'prefetch' &&\n          typeof sn.attributes.href === 'string' &&\n          extractFileExtension(sn.attributes.href) === 'js'))\n    ) {\n      return true;\n    } else if (\n      slimDOMOptions.headFavicon &&\n      ((sn.tagName === 'link' && sn.attributes.rel === 'shortcut icon') ||\n        (sn.tagName === 'meta' &&\n          (lowerIfExists(sn.attributes.name).match(\n            /^msapplication-tile(image|color)$/,\n          ) ||\n            lowerIfExists(sn.attributes.name) === 'application-name' ||\n            lowerIfExists(sn.attributes.rel) === 'icon' ||\n            lowerIfExists(sn.attributes.rel) === 'apple-touch-icon' ||\n            lowerIfExists(sn.attributes.rel) === 'shortcut icon')))\n    ) {\n      return true;\n    } else if (sn.tagName === 'meta') {\n      if (\n        slimDOMOptions.headMetaDescKeywords &&\n        lowerIfExists(sn.attributes.name).match(/^description|keywords$/)\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaSocial &&\n        (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)\n          lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) ||\n          lowerIfExists(sn.attributes.name) === 'pinterest')\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaRobots &&\n        (lowerIfExists(sn.attributes.name) === 'robots' ||\n          lowerIfExists(sn.attributes.name) === 'googlebot' ||\n          lowerIfExists(sn.attributes.name) === 'bingbot')\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaHttpEquiv &&\n        sn.attributes['http-equiv'] !== undefined\n      ) {\n        // e.g. X-UA-Compatible, Content-Type, Content-Language,\n        // cache-control, X-Translated-By\n        return true;\n      } else if (\n        slimDOMOptions.headMetaAuthorship &&\n        (lowerIfExists(sn.attributes.name) === 'author' ||\n          lowerIfExists(sn.attributes.name) === 'generator' ||\n          lowerIfExists(sn.attributes.name) === 'framework' ||\n          lowerIfExists(sn.attributes.name) === 'publisher' ||\n          lowerIfExists(sn.attributes.name) === 'progid' ||\n          lowerIfExists(sn.attributes.property).match(/^article:/) ||\n          lowerIfExists(sn.attributes.property).match(/^product:/))\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaVerification &&\n        (lowerIfExists(sn.attributes.name) === 'google-site-verification' ||\n          lowerIfExists(sn.attributes.name) === 'yandex-verification' ||\n          lowerIfExists(sn.attributes.name) === 'csrf-token' ||\n          lowerIfExists(sn.attributes.name) === 'p:domain_verify' ||\n          lowerIfExists(sn.attributes.name) === 'verify-v1' ||\n          lowerIfExists(sn.attributes.name) === 'verification' ||\n          lowerIfExists(sn.attributes.name) === 'shopify-checkout-api-token')\n      ) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nexport function serializeNodeWithId(\n  n: Node,\n  options: {\n    doc: Document;\n    mirror: Mirror;\n    blockClass: string | RegExp;\n    blockSelector: string | null;\n    maskTextClass: string | RegExp;\n    maskTextSelector: string | null;\n    skipChild: boolean;\n    inlineStylesheet: boolean;\n    newlyAddedElement?: boolean;\n    maskInputOptions?: MaskInputOptions;\n    needsMask?: boolean;\n    maskTextFn: MaskTextFn | undefined;\n    maskInputFn: MaskInputFn | undefined;\n    slimDOMOptions: SlimDOMOptions;\n    dataURLOptions?: DataURLOptions;\n    keepIframeSrcFn?: KeepIframeSrcFn;\n    inlineImages?: boolean;\n    recordCanvas?: boolean;\n    preserveWhiteSpace?: boolean;\n    onSerialize?: (n: Node) => unknown;\n    onIframeLoad?: (\n      iframeNode: HTMLIFrameElement,\n      node: serializedElementNodeWithId,\n    ) => unknown;\n    iframeLoadTimeout?: number;\n    onStylesheetLoad?: (\n      linkNode: HTMLLinkElement,\n      node: serializedElementNodeWithId,\n    ) => unknown;\n    stylesheetLoadTimeout?: number;\n  },\n): serializedNodeWithId | null {\n  const {\n    doc,\n    mirror,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    skipChild = false,\n    inlineStylesheet = true,\n    maskInputOptions = {},\n    maskTextFn,\n    maskInputFn,\n    slimDOMOptions,\n    dataURLOptions = {},\n    inlineImages = false,\n    recordCanvas = false,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout = 5000,\n    onStylesheetLoad,\n    stylesheetLoadTimeout = 5000,\n    keepIframeSrcFn = () => false,\n    newlyAddedElement = false,\n  } = options;\n  let { needsMask } = options;\n  let { preserveWhiteSpace = true } = options;\n\n  if (!needsMask) {\n    // perf: if needsMask = true, children won't also need to check\n    const checkAncestors = needsMask === undefined; // if false, we've already checked ancestors\n    needsMask = needMaskingText(\n      n as Element,\n      maskTextClass,\n      maskTextSelector,\n      checkAncestors,\n    );\n  }\n\n  const _serializedNode = serializeNode(n, {\n    doc,\n    mirror,\n    blockClass,\n    blockSelector,\n    needsMask,\n    inlineStylesheet,\n    maskInputOptions,\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions,\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement,\n  });\n  if (!_serializedNode) {\n    // TODO: dev only\n    console.warn(n, 'not serialized');\n    return null;\n  }\n\n  let id: number | undefined;\n  if (mirror.hasNode(n)) {\n    // Reuse the previous id\n    id = mirror.getId(n);\n  } else if (\n    slimDOMExcluded(_serializedNode, slimDOMOptions) ||\n    (!preserveWhiteSpace &&\n      _serializedNode.type === NodeType.Text &&\n      !_serializedNode.isStyle &&\n      !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, '').length)\n  ) {\n    id = IGNORED_NODE;\n  } else {\n    id = genId();\n  }\n\n  const serializedNode = Object.assign(_serializedNode, { id });\n  // add IGNORED_NODE to mirror to track nextSiblings\n  mirror.add(n, serializedNode);\n\n  if (id === IGNORED_NODE) {\n    return null; // slimDOM\n  }\n\n  if (onSerialize) {\n    onSerialize(n);\n  }\n  let recordChild = !skipChild;\n  if (serializedNode.type === NodeType.Element) {\n    recordChild = recordChild && !serializedNode.needBlock;\n    // this property was not needed in replay side\n    delete serializedNode.needBlock;\n    const shadowRoot = (n as HTMLElement).shadowRoot;\n    if (shadowRoot && isNativeShadowDom(shadowRoot))\n      serializedNode.isShadowHost = true;\n  }\n  if (\n    (serializedNode.type === NodeType.Document ||\n      serializedNode.type === NodeType.Element) &&\n    recordChild\n  ) {\n    if (\n      slimDOMOptions.headWhitespace &&\n      serializedNode.type === NodeType.Element &&\n      serializedNode.tagName === 'head'\n      // would impede performance: || getComputedStyle(n)['white-space'] === 'normal'\n    ) {\n      preserveWhiteSpace = false;\n    }\n    const bypassOptions = {\n      doc,\n      mirror,\n      blockClass,\n      blockSelector,\n      needsMask,\n      maskTextClass,\n      maskTextSelector,\n      skipChild,\n      inlineStylesheet,\n      maskInputOptions,\n      maskTextFn,\n      maskInputFn,\n      slimDOMOptions,\n      dataURLOptions,\n      inlineImages,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n      onStylesheetLoad,\n      stylesheetLoadTimeout,\n      keepIframeSrcFn,\n    };\n\n    if (\n      serializedNode.type === NodeType.Element &&\n      serializedNode.tagName === 'textarea' &&\n      (serializedNode as elementNode).attributes.value !== undefined\n    ) {\n      // value parameter in DOM reflects the correct value, so ignore childNode\n    } else {\n      for (const childN of Array.from(n.childNodes)) {\n        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n        if (serializedChildNode) {\n          serializedNode.childNodes.push(serializedChildNode);\n        }\n      }\n    }\n\n    if (isElement(n) && n.shadowRoot) {\n      for (const childN of Array.from(n.shadowRoot.childNodes)) {\n        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n        if (serializedChildNode) {\n          isNativeShadowDom(n.shadowRoot) &&\n            (serializedChildNode.isShadow = true);\n          serializedNode.childNodes.push(serializedChildNode);\n        }\n      }\n    }\n  }\n\n  if (\n    n.parentNode &&\n    isShadowRoot(n.parentNode) &&\n    isNativeShadowDom(n.parentNode)\n  ) {\n    serializedNode.isShadow = true;\n  }\n\n  if (\n    serializedNode.type === NodeType.Element &&\n    serializedNode.tagName === 'iframe'\n  ) {\n    onceIframeLoaded(\n      n as HTMLIFrameElement,\n      () => {\n        const iframeDoc = (n as HTMLIFrameElement).contentDocument;\n        if (iframeDoc && onIframeLoad) {\n          const serializedIframeNode = serializeNodeWithId(iframeDoc, {\n            doc: iframeDoc,\n            mirror,\n            blockClass,\n            blockSelector,\n            needsMask,\n            maskTextClass,\n            maskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputOptions,\n            maskTextFn,\n            maskInputFn,\n            slimDOMOptions,\n            dataURLOptions,\n            inlineImages,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n            onStylesheetLoad,\n            stylesheetLoadTimeout,\n            keepIframeSrcFn,\n          });\n\n          if (serializedIframeNode) {\n            onIframeLoad(\n              n as HTMLIFrameElement,\n              serializedIframeNode as serializedElementNodeWithId,\n            );\n          }\n        }\n      },\n      iframeLoadTimeout,\n    );\n  }\n\n  // <link rel=stylesheet href=...>\n  if (\n    serializedNode.type === NodeType.Element &&\n    serializedNode.tagName === 'link' &&\n    typeof serializedNode.attributes.rel === 'string' &&\n    (serializedNode.attributes.rel === 'stylesheet' ||\n      (serializedNode.attributes.rel === 'preload' &&\n        typeof serializedNode.attributes.href === 'string' &&\n        extractFileExtension(serializedNode.attributes.href) === 'css'))\n  ) {\n    onceStylesheetLoaded(\n      n as HTMLLinkElement,\n      () => {\n        if (onStylesheetLoad) {\n          const serializedLinkNode = serializeNodeWithId(n, {\n            doc,\n            mirror,\n            blockClass,\n            blockSelector,\n            needsMask,\n            maskTextClass,\n            maskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputOptions,\n            maskTextFn,\n            maskInputFn,\n            slimDOMOptions,\n            dataURLOptions,\n            inlineImages,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n            onStylesheetLoad,\n            stylesheetLoadTimeout,\n            keepIframeSrcFn,\n          });\n\n          if (serializedLinkNode) {\n            onStylesheetLoad(\n              n as HTMLLinkElement,\n              serializedLinkNode as serializedElementNodeWithId,\n            );\n          }\n        }\n      },\n      stylesheetLoadTimeout,\n    );\n  }\n\n  return serializedNode;\n}\n\nfunction snapshot(\n  n: Document,\n  options?: {\n    mirror?: Mirror;\n    blockClass?: string | RegExp;\n    blockSelector?: string | null;\n    maskTextClass?: string | RegExp;\n    maskTextSelector?: string | null;\n    inlineStylesheet?: boolean;\n    maskAllInputs?: boolean | MaskInputOptions;\n    maskTextFn?: MaskTextFn;\n    maskInputFn?: MaskInputFn;\n    slimDOM?: 'all' | boolean | SlimDOMOptions;\n    dataURLOptions?: DataURLOptions;\n    inlineImages?: boolean;\n    recordCanvas?: boolean;\n    preserveWhiteSpace?: boolean;\n    onSerialize?: (n: Node) => unknown;\n    onIframeLoad?: (\n      iframeNode: HTMLIFrameElement,\n      node: serializedElementNodeWithId,\n    ) => unknown;\n    iframeLoadTimeout?: number;\n    onStylesheetLoad?: (\n      linkNode: HTMLLinkElement,\n      node: serializedElementNodeWithId,\n    ) => unknown;\n    stylesheetLoadTimeout?: number;\n    keepIframeSrcFn?: KeepIframeSrcFn;\n  },\n): serializedNodeWithId | null {\n  const {\n    mirror = new Mirror(),\n    blockClass = 'rr-block',\n    blockSelector = null,\n    maskTextClass = 'rr-mask',\n    maskTextSelector = null,\n    inlineStylesheet = true,\n    inlineImages = false,\n    recordCanvas = false,\n    maskAllInputs = false,\n    maskTextFn,\n    maskInputFn,\n    slimDOM = false,\n    dataURLOptions,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n    onStylesheetLoad,\n    stylesheetLoadTimeout,\n    keepIframeSrcFn = () => false,\n  } = options || {};\n  const maskInputOptions: MaskInputOptions =\n    maskAllInputs === true\n      ? {\n          color: true,\n          date: true,\n          'datetime-local': true,\n          email: true,\n          month: true,\n          number: true,\n          range: true,\n          search: true,\n          tel: true,\n          text: true,\n          time: true,\n          url: true,\n          week: true,\n          textarea: true,\n          select: true,\n          password: true,\n        }\n      : maskAllInputs === false\n      ? {\n          password: true,\n        }\n      : maskAllInputs;\n  const slimDOMOptions: SlimDOMOptions =\n    slimDOM === true || slimDOM === 'all'\n      ? // if true: set of sensible options that should not throw away any information\n        {\n          script: true,\n          comment: true,\n          headFavicon: true,\n          headWhitespace: true,\n          headMetaDescKeywords: slimDOM === 'all', // destructive\n          headMetaSocial: true,\n          headMetaRobots: true,\n          headMetaHttpEquiv: true,\n          headMetaAuthorship: true,\n          headMetaVerification: true,\n        }\n      : slimDOM === false\n      ? {}\n      : slimDOM;\n  return serializeNodeWithId(n, {\n    doc: n,\n    mirror,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    skipChild: false,\n    inlineStylesheet,\n    maskInputOptions,\n    maskTextFn,\n    maskInputFn,\n    slimDOMOptions,\n    dataURLOptions,\n    inlineImages,\n    recordCanvas,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n    onStylesheetLoad,\n    stylesheetLoadTimeout,\n    keepIframeSrcFn,\n    newlyAddedElement: false,\n  });\n}\n\nexport function visitSnapshot(\n  node: serializedNodeWithId,\n  onVisit: (node: serializedNodeWithId) => unknown,\n) {\n  function walk(current: serializedNodeWithId) {\n    onVisit(current);\n    if (\n      current.type === NodeType.Document ||\n      current.type === NodeType.Element\n    ) {\n      current.childNodes.forEach(walk);\n    }\n  }\n\n  walk(node);\n}\n\nexport function cleanupSnapshot() {\n  // allow a new recording to start numbering nodes from scratch\n  _id = 1;\n}\n\nexport default snapshot;\n","/**\n * This file is a fork of https://github.com/reworkcss/css/blob/master/lib/parse/index.js\n * I fork it because:\n * 1. The css library was built for node.js which does not have tree-shaking supports.\n * 2. Rewrites into typescript give us a better type interface.\n */\n/* eslint-disable tsdoc/syntax */\n\nexport interface ParserOptions {\n  /** Silently fail on parse errors */\n  silent?: boolean;\n  /**\n   * The path to the file containing css.\n   * Makes errors and source maps more helpful, by letting them know where code comes from.\n   */\n  source?: string;\n}\n\n/**\n * Error thrown during parsing.\n */\nexport interface ParserError {\n  /** The full error message with the source position. */\n  message?: string;\n  /** The error message without position. */\n  reason?: string;\n  /** The value of options.source if passed to css.parse. Otherwise undefined. */\n  filename?: string;\n  line?: number;\n  column?: number;\n  /** The portion of code that couldn't be parsed. */\n  source?: string;\n}\n\nexport interface Loc {\n  line?: number;\n  column?: number;\n}\n\n/**\n * Base AST Tree Node.\n */\nexport interface Node {\n  /** The possible values are the ones listed in the Types section on https://github.com/reworkcss/css page. */\n  type?: string;\n  /** A reference to the parent node, or null if the node has no parent. */\n  parent?: Node;\n  /** Information about the position in the source string that corresponds to the node. */\n  position?: {\n    start?: Loc;\n    end?: Loc;\n    /** The value of options.source if passed to css.parse. Otherwise undefined. */\n    source?: string;\n    /** The full source string passed to css.parse. */\n    content?: string;\n  };\n}\n\nexport interface NodeWithRules extends Node {\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules: Array<Rule | Comment | AtRule>;\n}\n\nexport interface Rule extends Node {\n  /** The list of selectors of the rule, split on commas. Each selector is trimmed from whitespace and comments. */\n  selectors?: string[];\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\nexport interface Declaration extends Node {\n  /** The property name, trimmed from whitespace and comments. May not be empty. */\n  property?: string;\n  /** The value of the property, trimmed from whitespace and comments. Empty values are allowed. */\n  value?: string;\n}\n\n/**\n * A rule-level or declaration-level comment. Comments inside selectors, properties and values etc. are lost.\n */\nexport interface Comment extends Node {\n  comment?: string;\n}\n\n/**\n * The @charset at-rule.\n */\nexport interface Charset extends Node {\n  /** The part following @charset. */\n  charset?: string;\n}\n\n/**\n * The @custom-media at-rule\n */\nexport interface CustomMedia extends Node {\n  /** The ---prefixed name. */\n  name?: string;\n  /** The part following the name. */\n  media?: string;\n}\n\n/**\n * The @document at-rule.\n */\nexport interface Document extends NodeWithRules {\n  /** The part following @document. */\n  document?: string;\n  /** The vendor prefix in @document, or undefined if there is none. */\n  vendor?: string;\n}\n\n/**\n * The @font-face at-rule.\n */\nexport interface FontFace extends Node {\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\n/**\n * The @host at-rule.\n */\nexport type Host = NodeWithRules;\n\n/**\n * The @import at-rule.\n */\nexport interface Import extends Node {\n  /** The part following @import. */\n  import?: string;\n}\n\n/**\n * The @keyframes at-rule.\n */\nexport interface KeyFrames extends Node {\n  /** The name of the keyframes rule. */\n  name?: string;\n  /** The vendor prefix in @keyframes, or undefined if there is none. */\n  vendor?: string;\n  /** Array of nodes with the types keyframe and comment. */\n  keyframes?: Array<KeyFrame | Comment>;\n}\n\nexport interface KeyFrame extends Node {\n  /** The list of \"selectors\" of the keyframe rule, split on commas. Each selector is trimmed from whitespace. */\n  values?: string[];\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\n/**\n * The @media at-rule.\n */\nexport interface Media extends NodeWithRules {\n  /** The part following @media. */\n  media?: string;\n}\n\n/**\n * The @namespace at-rule.\n */\nexport interface Namespace extends Node {\n  /** The part following @namespace. */\n  namespace?: string;\n}\n\n/**\n * The @page at-rule.\n */\nexport interface Page extends Node {\n  /** The list of selectors of the rule, split on commas. Each selector is trimmed from whitespace and comments. */\n  selectors?: string[];\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\n/**\n * The @supports at-rule.\n */\nexport interface Supports extends NodeWithRules {\n  /** The part following @supports. */\n  supports?: string;\n}\n\n/** All at-rules. */\nexport type AtRule =\n  | Charset\n  | CustomMedia\n  | Document\n  | FontFace\n  | Host\n  | Import\n  | KeyFrames\n  | Media\n  | Namespace\n  | Page\n  | Supports;\n\n/**\n * A collection of rules\n */\nexport interface StyleRules extends NodeWithRules {\n  source?: string;\n  /** Array of Errors. Errors collected during parsing when option silent is true. */\n  parsingErrors?: ParserError[];\n}\n\n/**\n * The root node returned by css.parse.\n */\nexport interface Stylesheet extends Node {\n  stylesheet?: StyleRules;\n}\n\n// http://www.w3.org/TR/CSS21/grammar.html\n// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027\nconst commentre = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\n\nexport function parse(css: string, options: ParserOptions = {}): Stylesheet {\n  /**\n   * Positional.\n   */\n\n  let lineno = 1;\n  let column = 1;\n\n  /**\n   * Update lineno and column based on `str`.\n   */\n\n  function updatePosition(str: string) {\n    const lines = str.match(/\\n/g);\n    if (lines) {\n      lineno += lines.length;\n    }\n    const i = str.lastIndexOf('\\n');\n    column = i === -1 ? column + str.length : str.length - i;\n  }\n\n  /**\n   * Mark position and patch `node.position`.\n   */\n\n  function position() {\n    const start = { line: lineno, column };\n    return (\n      node: Rule | Declaration | Comment | AtRule | Stylesheet | KeyFrame,\n    ) => {\n      node.position = new Position(start);\n      whitespace();\n      return node;\n    };\n  }\n\n  /**\n   * Store position information for a node\n   */\n\n  class Position {\n    public static content: string;\n    public content!: string;\n    public start!: Loc;\n    public end!: Loc;\n    public source?: string;\n\n    constructor(start: Loc) {\n      this.start = start;\n      this.end = { line: lineno, column };\n      this.source = options.source;\n      this.content = Position.content;\n    }\n  }\n\n  /**\n   * Non-enumerable source string\n   */\n\n  Position.content = css;\n\n  const errorsList: ParserError[] = [];\n\n  function error(msg: string) {\n    const err = new Error(\n      `${options.source || ''}:${lineno}:${column}: ${msg}`,\n    ) as ParserError;\n    err.reason = msg;\n    err.filename = options.source;\n    err.line = lineno;\n    err.column = column;\n    err.source = css;\n\n    if (options.silent) {\n      errorsList.push(err);\n    } else {\n      throw err;\n    }\n  }\n\n  /**\n   * Parse stylesheet.\n   */\n\n  function stylesheet(): Stylesheet {\n    const rulesList = rules();\n\n    return {\n      type: 'stylesheet',\n      stylesheet: {\n        source: options.source,\n        rules: rulesList,\n        parsingErrors: errorsList,\n      },\n    };\n  }\n\n  /**\n   * Opening brace.\n   */\n\n  function open() {\n    return match(/^{\\s*/);\n  }\n\n  /**\n   * Closing brace.\n   */\n\n  function close() {\n    return match(/^}/);\n  }\n\n  /**\n   * Parse ruleset.\n   */\n\n  function rules() {\n    let node: Rule | void;\n    const rules: Rule[] = [];\n    whitespace();\n    comments(rules);\n    while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {\n      if (node) {\n        rules.push(node);\n        comments(rules);\n      }\n    }\n    return rules;\n  }\n\n  /**\n   * Match `re` and return captures.\n   */\n\n  function match(re: RegExp) {\n    const m = re.exec(css);\n    if (!m) {\n      return;\n    }\n    const str = m[0];\n    updatePosition(str);\n    css = css.slice(str.length);\n    return m;\n  }\n\n  /**\n   * Parse whitespace.\n   */\n\n  function whitespace() {\n    match(/^\\s*/);\n  }\n\n  /**\n   * Parse comments;\n   */\n\n  function comments(rules: Rule[] = []) {\n    let c: Comment | void;\n    while ((c = comment())) {\n      if (c) {\n        rules.push(c);\n      }\n      c = comment();\n    }\n    return rules;\n  }\n\n  /**\n   * Parse comment.\n   */\n\n  function comment() {\n    const pos = position();\n    if ('/' !== css.charAt(0) || '*' !== css.charAt(1)) {\n      return;\n    }\n\n    let i = 2;\n    while (\n      '' !== css.charAt(i) &&\n      ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1))\n    ) {\n      ++i;\n    }\n    i += 2;\n\n    if ('' === css.charAt(i - 1)) {\n      return error('End of comment missing');\n    }\n\n    const str = css.slice(2, i - 2);\n    column += 2;\n    updatePosition(str);\n    css = css.slice(i);\n    column += 2;\n\n    return pos({\n      type: 'comment',\n      comment: str,\n    });\n  }\n\n  /**\n   * Parse selector.\n   */\n\n  // originally from https://github.com/NxtChg/pieces/blob/3eb39c8287a97632e9347a24f333d52d916bc816/js/css_parser/css_parse.js#L46C1-L47C1\n  const selectorMatcher = new RegExp(\n    '^((' +\n      [\n        /[^\\\\]\"(?:\\\\\"|[^\"])*\"/.source, // consume any quoted parts (checking that the double quote isn't itself escaped)\n        /[^\\\\]'(?:\\\\'|[^'])*'/.source, // same but for single quotes\n        '[^{]',\n      ].join('|') +\n      ')+)',\n  );\n\n  function selector() {\n    whitespace();\n    while (css[0] == '}') {\n      error('extra closing bracket');\n      css = css.slice(1);\n      whitespace();\n    }\n\n    const m = match(selectorMatcher);\n    if (!m) {\n      return;\n    }\n\n    /* @fix Remove all comments from selectors\n     * http://ostermiller.org/findcomment.html */\n    const cleanedInput = m[0]\n      .trim()\n      .replace(/\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*\\/+/g, '')\n\n      // Handle strings by replacing commas inside them\n      .replace(/\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'/g, (m) => {\n        return m.replace(/,/g, '\\u200C');\n      });\n\n    // Split using a custom function and restore commas in strings\n    return customSplit(cleanedInput).map((s) =>\n      s.replace(/\\u200C/g, ',').trim(),\n    );\n  }\n\n  /**\n   * Split selector correctly, ensuring not to split on comma if inside ().\n   */\n\n  function customSplit(input: string) {\n    const result = [];\n    let currentSegment = '';\n    let depthParentheses = 0; // Track depth of parentheses\n    let depthBrackets = 0; // Track depth of square brackets\n    let currentStringChar = null;\n\n    for (const char of input) {\n      const hasStringEscape = currentSegment.endsWith('\\\\');\n\n      if (currentStringChar) {\n        if (currentStringChar === char && !hasStringEscape) {\n          currentStringChar = null;\n        }\n      } else if (char === '(') {\n        depthParentheses++;\n      } else if (char === ')') {\n        depthParentheses--;\n      } else if (char === '[') {\n        depthBrackets++;\n      } else if (char === ']') {\n        depthBrackets--;\n      } else if ('\\'\"'.includes(char)) {\n        currentStringChar = char;\n      }\n\n      // Split point is a comma that is not inside parentheses or square brackets\n      if (char === ',' && depthParentheses === 0 && depthBrackets === 0) {\n        result.push(currentSegment);\n        currentSegment = '';\n      } else {\n        currentSegment += char;\n      }\n    }\n\n    // Add the last segment\n    if (currentSegment) {\n      result.push(currentSegment);\n    }\n\n    return result;\n  }\n\n  /**\n   * Parse declaration.\n   */\n\n  function declaration(): Declaration | void | never {\n    const pos = position();\n\n    // prop\n    // eslint-disable-next-line no-useless-escape\n    const propMatch = match(/^(\\*?[-#\\/\\*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/);\n    if (!propMatch) {\n      return;\n    }\n    const prop = trim(propMatch[0]);\n\n    // :\n    if (!match(/^:\\s*/)) {\n      return error(`property missing ':'`);\n    }\n\n    // val\n    // eslint-disable-next-line no-useless-escape\n    const val = match(/^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+)/);\n\n    const ret = pos({\n      type: 'declaration',\n      property: prop.replace(commentre, ''),\n      value: val ? trim(val[0]).replace(commentre, '') : '',\n    });\n\n    // ;\n    match(/^[;\\s]*/);\n\n    return ret;\n  }\n\n  /**\n   * Parse declarations.\n   */\n\n  function declarations() {\n    const decls: Array<object> = [];\n\n    if (!open()) {\n      return error(`missing '{'`);\n    }\n    comments(decls);\n\n    // declarations\n    let decl;\n    while ((decl = declaration())) {\n      if ((decl as unknown) !== false) {\n        decls.push(decl);\n        comments(decls);\n      }\n      decl = declaration();\n    }\n\n    if (!close()) {\n      return error(`missing '}'`);\n    }\n    return decls;\n  }\n\n  /**\n   * Parse keyframe.\n   */\n\n  function keyframe() {\n    let m;\n    const vals = [];\n    const pos = position();\n\n    while ((m = match(/^((\\d+\\.\\d+|\\.\\d+|\\d+)%?|[a-z]+)\\s*/))) {\n      vals.push(m[1]);\n      match(/^,\\s*/);\n    }\n\n    if (!vals.length) {\n      return;\n    }\n\n    return pos({\n      type: 'keyframe',\n      values: vals,\n      declarations: declarations() as Declaration[],\n    });\n  }\n\n  /**\n   * Parse keyframes.\n   */\n\n  function atkeyframes() {\n    const pos = position();\n    let m = match(/^@([-\\w]+)?keyframes\\s*/);\n\n    if (!m) {\n      return;\n    }\n    const vendor = m[1];\n\n    // identifier\n    m = match(/^([-\\w]+)\\s*/);\n    if (!m) {\n      return error('@keyframes missing name');\n    }\n    const name = m[1];\n\n    if (!open()) {\n      return error(`@keyframes missing '{'`);\n    }\n\n    let frame;\n    let frames = comments();\n    while ((frame = keyframe())) {\n      frames.push(frame);\n      frames = frames.concat(comments());\n    }\n\n    if (!close()) {\n      return error(`@keyframes missing '}'`);\n    }\n\n    return pos({\n      type: 'keyframes',\n      name,\n      vendor,\n      keyframes: frames,\n    });\n  }\n\n  /**\n   * Parse supports.\n   */\n\n  function atsupports() {\n    const pos = position();\n    const m = match(/^@supports *([^{]+)/);\n\n    if (!m) {\n      return;\n    }\n    const supports = trim(m[1]);\n\n    if (!open()) {\n      return error(`@supports missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@supports missing '}'`);\n    }\n\n    return pos({\n      type: 'supports',\n      supports,\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse host.\n   */\n\n  function athost() {\n    const pos = position();\n    const m = match(/^@host\\s*/);\n\n    if (!m) {\n      return;\n    }\n\n    if (!open()) {\n      return error(`@host missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@host missing '}'`);\n    }\n\n    return pos({\n      type: 'host',\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse media.\n   */\n\n  function atmedia() {\n    const pos = position();\n    const m = match(/^@media *([^{]+)/);\n\n    if (!m) {\n      return;\n    }\n    const media = trim(m[1]);\n\n    if (!open()) {\n      return error(`@media missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@media missing '}'`);\n    }\n\n    return pos({\n      type: 'media',\n      media,\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse custom-media.\n   */\n\n  function atcustommedia() {\n    const pos = position();\n    const m = match(/^@custom-media\\s+(--[^\\s]+)\\s*([^{;]+);/);\n    if (!m) {\n      return;\n    }\n\n    return pos({\n      type: 'custom-media',\n      name: trim(m[1]),\n      media: trim(m[2]),\n    });\n  }\n\n  /**\n   * Parse paged media.\n   */\n\n  function atpage() {\n    const pos = position();\n    const m = match(/^@page */);\n    if (!m) {\n      return;\n    }\n\n    const sel = selector() || [];\n\n    if (!open()) {\n      return error(`@page missing '{'`);\n    }\n    let decls = comments();\n\n    // declarations\n    let decl;\n    while ((decl = declaration())) {\n      decls.push(decl);\n      decls = decls.concat(comments());\n    }\n\n    if (!close()) {\n      return error(`@page missing '}'`);\n    }\n\n    return pos({\n      type: 'page',\n      selectors: sel,\n      declarations: decls,\n    });\n  }\n\n  /**\n   * Parse document.\n   */\n\n  function atdocument() {\n    const pos = position();\n    const m = match(/^@([-\\w]+)?document *([^{]+)/);\n    if (!m) {\n      return;\n    }\n\n    const vendor = trim(m[1]);\n    const doc = trim(m[2]);\n\n    if (!open()) {\n      return error(`@document missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@document missing '}'`);\n    }\n\n    return pos({\n      type: 'document',\n      document: doc,\n      vendor,\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse font-face.\n   */\n\n  function atfontface() {\n    const pos = position();\n    const m = match(/^@font-face\\s*/);\n    if (!m) {\n      return;\n    }\n\n    if (!open()) {\n      return error(`@font-face missing '{'`);\n    }\n    let decls = comments();\n\n    // declarations\n    let decl;\n    while ((decl = declaration())) {\n      decls.push(decl);\n      decls = decls.concat(comments());\n    }\n\n    if (!close()) {\n      return error(`@font-face missing '}'`);\n    }\n\n    return pos({\n      type: 'font-face',\n      declarations: decls,\n    });\n  }\n\n  /**\n   * Parse import\n   */\n\n  const atimport = _compileAtrule('import');\n\n  /**\n   * Parse charset\n   */\n\n  const atcharset = _compileAtrule('charset');\n\n  /**\n   * Parse namespace\n   */\n\n  const atnamespace = _compileAtrule('namespace');\n\n  /**\n   * Parse non-block at-rules\n   */\n\n  function _compileAtrule(name: string) {\n    const re = new RegExp(\n      '^@' +\n        name +\n        '\\\\s*((?:' +\n        [\n          /[^\\\\]\"(?:\\\\\"|[^\"])*\"/.source, // consume any quoted parts (checking that the double quote isn't itself escaped)\n          /[^\\\\]'(?:\\\\'|[^'])*'/.source, // same but for single quotes\n          '[^;]',\n        ].join('|') +\n        ')+);',\n    );\n    return () => {\n      const pos = position();\n      const m = match(re);\n      if (!m) {\n        return;\n      }\n      const ret: Record<string, string> = { type: name };\n      ret[name] = m[1].trim();\n      return pos(ret);\n    };\n  }\n\n  /**\n   * Parse at rule.\n   */\n\n  function atrule() {\n    if (css[0] !== '@') {\n      return;\n    }\n\n    return (\n      atkeyframes() ||\n      atmedia() ||\n      atcustommedia() ||\n      atsupports() ||\n      atimport() ||\n      atcharset() ||\n      atnamespace() ||\n      atdocument() ||\n      atpage() ||\n      athost() ||\n      atfontface()\n    );\n  }\n\n  /**\n   * Parse rule.\n   */\n\n  function rule() {\n    const pos = position();\n    const sel = selector();\n\n    if (!sel) {\n      return error('selector missing');\n    }\n    comments();\n\n    return pos({\n      type: 'rule',\n      selectors: sel,\n      declarations: declarations() as Declaration[],\n    });\n  }\n\n  return addParent(stylesheet());\n}\n\n/**\n * Trim `str`.\n */\n\nfunction trim(str: string) {\n  return str ? str.replace(/^\\s+|\\s+$/g, '') : '';\n}\n\n/**\n * Adds non-enumerable parent node reference to each node.\n */\n\nfunction addParent(obj: Stylesheet, parent?: Stylesheet): Stylesheet {\n  const isNode = obj && typeof obj.type === 'string';\n  const childParent = isNode ? obj : parent;\n\n  for (const k of Object.keys(obj)) {\n    const value = obj[k as keyof Stylesheet];\n    if (Array.isArray(value)) {\n      value.forEach((v) => {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        addParent(v, childParent);\n      });\n    } else if (value && typeof value === 'object') {\n      addParent(value as Stylesheet, childParent);\n    }\n  }\n\n  if (isNode) {\n    Object.defineProperty(obj, 'parent', {\n      configurable: true,\n      writable: true,\n      enumerable: false,\n      value: parent || null,\n    });\n  }\n\n  return obj;\n}\n","import { type Rule, type Media, type NodeWithRules, parse } from './css';\nimport {\n  type serializedNodeWithId,\n  NodeType,\n  type tagMap,\n  type elementNode,\n  type BuildCache,\n  type legacyAttributes,\n} from './types';\nimport { isElement, Mirror, isNodeMetaEqual } from './utils';\n\nconst tagMap: tagMap = {\n  script: 'noscript',\n  // camel case svg element tag names\n  altglyph: 'altGlyph',\n  altglyphdef: 'altGlyphDef',\n  altglyphitem: 'altGlyphItem',\n  animatecolor: 'animateColor',\n  animatemotion: 'animateMotion',\n  animatetransform: 'animateTransform',\n  clippath: 'clipPath',\n  feblend: 'feBlend',\n  fecolormatrix: 'feColorMatrix',\n  fecomponenttransfer: 'feComponentTransfer',\n  fecomposite: 'feComposite',\n  feconvolvematrix: 'feConvolveMatrix',\n  fediffuselighting: 'feDiffuseLighting',\n  fedisplacementmap: 'feDisplacementMap',\n  fedistantlight: 'feDistantLight',\n  fedropshadow: 'feDropShadow',\n  feflood: 'feFlood',\n  fefunca: 'feFuncA',\n  fefuncb: 'feFuncB',\n  fefuncg: 'feFuncG',\n  fefuncr: 'feFuncR',\n  fegaussianblur: 'feGaussianBlur',\n  feimage: 'feImage',\n  femerge: 'feMerge',\n  femergenode: 'feMergeNode',\n  femorphology: 'feMorphology',\n  feoffset: 'feOffset',\n  fepointlight: 'fePointLight',\n  fespecularlighting: 'feSpecularLighting',\n  fespotlight: 'feSpotLight',\n  fetile: 'feTile',\n  feturbulence: 'feTurbulence',\n  foreignobject: 'foreignObject',\n  glyphref: 'glyphRef',\n  lineargradient: 'linearGradient',\n  radialgradient: 'radialGradient',\n};\nfunction getTagName(n: elementNode): string {\n  let tagName = tagMap[n.tagName] ? tagMap[n.tagName] : n.tagName;\n  if (tagName === 'link' && n.attributes._cssText) {\n    tagName = 'style';\n  }\n  return tagName;\n}\n\n// based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#escaping\nfunction escapeRegExp(str: string) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nconst MEDIA_SELECTOR = /(max|min)-device-(width|height)/;\nconst MEDIA_SELECTOR_GLOBAL = new RegExp(MEDIA_SELECTOR.source, 'g');\nconst HOVER_SELECTOR = /([^\\\\]):hover/;\nconst HOVER_SELECTOR_GLOBAL = new RegExp(HOVER_SELECTOR.source, 'g');\nexport function adaptCssForReplay(cssText: string, cache: BuildCache): string {\n  const cachedStyle = cache?.stylesWithHoverClass.get(cssText);\n  if (cachedStyle) return cachedStyle;\n\n  const ast = parse(cssText, {\n    silent: true,\n  });\n\n  if (!ast.stylesheet) {\n    return cssText;\n  }\n\n  const selectors: string[] = [];\n  const medias: string[] = [];\n  function getSelectors(rule: Rule | Media | NodeWithRules) {\n    if ('selectors' in rule && rule.selectors) {\n      rule.selectors.forEach((selector: string) => {\n        if (HOVER_SELECTOR.test(selector)) {\n          selectors.push(selector);\n        }\n      });\n    }\n    if ('media' in rule && rule.media && MEDIA_SELECTOR.test(rule.media)) {\n      medias.push(rule.media);\n    }\n    if ('rules' in rule && rule.rules) {\n      rule.rules.forEach(getSelectors);\n    }\n  }\n  getSelectors(ast.stylesheet);\n\n  let result = cssText;\n  if (selectors.length > 0) {\n    const selectorMatcher = new RegExp(\n      selectors\n        .filter((selector, index) => selectors.indexOf(selector) === index)\n        .sort((a, b) => b.length - a.length)\n        .map((selector) => {\n          return escapeRegExp(selector);\n        })\n        .join('|'),\n      'g',\n    );\n    result = result.replace(selectorMatcher, (selector) => {\n      const newSelector = selector.replace(\n        HOVER_SELECTOR_GLOBAL,\n        '$1.\\\\:hover',\n      );\n      return `${selector}, ${newSelector}`;\n    });\n  }\n  if (medias.length > 0) {\n    const mediaMatcher = new RegExp(\n      medias\n        .filter((media, index) => medias.indexOf(media) === index)\n        .sort((a, b) => b.length - a.length)\n        .map((media) => {\n          return escapeRegExp(media);\n        })\n        .join('|'),\n      'g',\n    );\n    result = result.replace(mediaMatcher, (media) => {\n      // not attempting to maintain min-device-width along with min-width\n      // (it's non standard)\n      return media.replace(MEDIA_SELECTOR_GLOBAL, '$1-$2');\n    });\n  }\n  cache?.stylesWithHoverClass.set(cssText, result);\n  return result;\n}\n\nexport function createCache(): BuildCache {\n  const stylesWithHoverClass: Map<string, string> = new Map();\n  return {\n    stylesWithHoverClass,\n  };\n}\n\nfunction buildNode(\n  n: serializedNodeWithId,\n  options: {\n    doc: Document;\n    hackCss: boolean;\n    cache: BuildCache;\n  },\n): Node | null {\n  const { doc, hackCss, cache } = options;\n  switch (n.type) {\n    case NodeType.Document:\n      return doc.implementation.createDocument(null, '', null);\n    case NodeType.DocumentType:\n      return doc.implementation.createDocumentType(\n        n.name || 'html',\n        n.publicId,\n        n.systemId,\n      );\n    case NodeType.Element: {\n      const tagName = getTagName(n);\n      let node: Element;\n      if (n.isSVG) {\n        node = doc.createElementNS('http://www.w3.org/2000/svg', tagName);\n      } else {\n        if (\n          // If the tag name is a custom element name\n          n.isCustom &&\n          // If the browser supports custom elements\n          doc.defaultView?.customElements &&\n          // If the custom element hasn't been defined yet\n          !doc.defaultView.customElements.get(n.tagName)\n        )\n          doc.defaultView.customElements.define(\n            n.tagName,\n            class extends doc.defaultView.HTMLElement {},\n          );\n        node = doc.createElement(tagName);\n      }\n      /**\n       * Attribute names start with `rr_` are internal attributes added by rrweb.\n       * They often overwrite other attributes on the element.\n       * We need to parse them last so they can overwrite conflicting attributes.\n       */\n      const specialAttributes: { [key: string]: string | number } = {};\n      for (const name in n.attributes) {\n        if (!Object.prototype.hasOwnProperty.call(n.attributes, name)) {\n          continue;\n        }\n        let value = n.attributes[name];\n        if (\n          tagName === 'option' &&\n          name === 'selected' &&\n          (value as legacyAttributes[typeof name]) === false\n        ) {\n          // legacy fix (TODO: if `value === false` can be generated for other attrs,\n          // should we also omit those other attrs from build ?)\n          continue;\n        }\n\n        // null values mean the attribute was removed\n        if (value === null) {\n          continue;\n        }\n\n        /**\n         * Boolean attributes are considered to be true if they're present on the element at all.\n         * We should set value to the empty string (\"\") or the attribute's name, with no leading or trailing whitespace.\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute#parameters\n         */\n        if (value === true) value = '';\n\n        if (name.startsWith('rr_')) {\n          specialAttributes[name] = value;\n          continue;\n        }\n\n        const isTextarea = tagName === 'textarea' && name === 'value';\n        const isRemoteOrDynamicCss = tagName === 'style' && name === '_cssText';\n        if (isRemoteOrDynamicCss && hackCss && typeof value === 'string') {\n          value = adaptCssForReplay(value, cache);\n        }\n        if ((isTextarea || isRemoteOrDynamicCss) && typeof value === 'string') {\n          node.appendChild(doc.createTextNode(value));\n          // https://github.com/rrweb-io/rrweb/issues/112\n          n.childNodes = []; // value overrides childNodes\n          continue;\n        }\n\n        try {\n          if (n.isSVG && name === 'xlink:href') {\n            node.setAttributeNS(\n              'http://www.w3.org/1999/xlink',\n              name,\n              value.toString(),\n            );\n          } else if (\n            name === 'onload' ||\n            name === 'onclick' ||\n            name.substring(0, 7) === 'onmouse'\n          ) {\n            // Rename some of the more common atttributes from https://www.w3schools.com/tags/ref_eventattributes.asp\n            // as setting them triggers a console.error (which shows up despite the try/catch)\n            // Assumption: these attributes are not used to css\n            node.setAttribute('_' + name, value.toString());\n          } else if (\n            tagName === 'meta' &&\n            n.attributes['http-equiv'] === 'Content-Security-Policy' &&\n            name === 'content'\n          ) {\n            // If CSP contains style-src and inline-style is disabled, there will be an error \"Refused to apply inline style because it violates the following Content Security Policy directive: style-src '*'\".\n            // And the function insertStyleRules in rrweb replayer will throw an error \"Uncaught TypeError: Cannot read property 'insertRule' of null\".\n            node.setAttribute('csp-content', value.toString());\n            continue;\n          } else if (\n            tagName === 'link' &&\n            (n.attributes.rel === 'preload' ||\n              n.attributes.rel === 'modulepreload') &&\n            n.attributes.as === 'script'\n          ) {\n            // ignore\n          } else if (\n            tagName === 'link' &&\n            n.attributes.rel === 'prefetch' &&\n            typeof n.attributes.href === 'string' &&\n            n.attributes.href.endsWith('.js')\n          ) {\n            // ignore\n          } else if (\n            tagName === 'img' &&\n            n.attributes.srcset &&\n            n.attributes.rr_dataURL\n          ) {\n            // backup original img srcset\n            node.setAttribute(\n              'rrweb-original-srcset',\n              n.attributes.srcset as string,\n            );\n          } else {\n            node.setAttribute(name, value.toString());\n          }\n        } catch (error) {\n          // skip invalid attribute\n        }\n      }\n\n      for (const name in specialAttributes) {\n        const value = specialAttributes[name];\n        // handle internal attributes\n        if (tagName === 'canvas' && name === 'rr_dataURL') {\n          const image = doc.createElement('img');\n          image.onload = () => {\n            const ctx = (node as HTMLCanvasElement).getContext('2d');\n            if (ctx) {\n              ctx.drawImage(image, 0, 0, image.width, image.height);\n            }\n          };\n          image.src = value.toString();\n          type RRCanvasElement = {\n            RRNodeType: NodeType;\n            rr_dataURL: string;\n          };\n          // If the canvas element is created in RRDom runtime (seeking to a time point), the canvas context isn't supported. So the data has to be stored and not handled until diff process. https://github.com/rrweb-io/rrweb/pull/944\n          if ((node as unknown as RRCanvasElement).RRNodeType)\n            (node as unknown as RRCanvasElement).rr_dataURL = value.toString();\n        } else if (tagName === 'img' && name === 'rr_dataURL') {\n          const image = node as HTMLImageElement;\n          if (!image.currentSrc.startsWith('data:')) {\n            // Backup original img src. It may not have been set yet.\n            image.setAttribute(\n              'rrweb-original-src',\n              n.attributes.src as string,\n            );\n            image.src = value.toString();\n          }\n        }\n\n        if (name === 'rr_width') {\n          (node as HTMLElement).style.width = value.toString();\n        } else if (name === 'rr_height') {\n          (node as HTMLElement).style.height = value.toString();\n        } else if (\n          name === 'rr_mediaCurrentTime' &&\n          typeof value === 'number'\n        ) {\n          (node as HTMLMediaElement).currentTime = value;\n        } else if (name === 'rr_mediaState') {\n          switch (value) {\n            case 'played':\n              (node as HTMLMediaElement)\n                .play()\n                .catch((e) => console.warn('media playback error', e));\n              break;\n            case 'paused':\n              (node as HTMLMediaElement).pause();\n              break;\n            default:\n          }\n        } else if (\n          name === 'rr_mediaPlaybackRate' &&\n          typeof value === 'number'\n        ) {\n          (node as HTMLMediaElement).playbackRate = value;\n        } else if (name === 'rr_mediaMuted' && typeof value === 'boolean') {\n          (node as HTMLMediaElement).muted = value;\n        } else if (name === 'rr_mediaLoop' && typeof value === 'boolean') {\n          (node as HTMLMediaElement).loop = value;\n        } else if (name === 'rr_mediaVolume' && typeof value === 'number') {\n          (node as HTMLMediaElement).volume = value;\n        }\n      }\n\n      if (n.isShadowHost) {\n        /**\n         * Since node is newly rebuilt, it should be a normal element\n         * without shadowRoot.\n         * But if there are some weird situations that has defined\n         * custom element in the scope before we rebuild node, it may\n         * register the shadowRoot earlier.\n         * The logic in the 'else' block is just a try-my-best solution\n         * for the corner case, please let we know if it is wrong and\n         * we can remove it.\n         */\n        if (!node.shadowRoot) {\n          node.attachShadow({ mode: 'open' });\n        } else {\n          while (node.shadowRoot.firstChild) {\n            node.shadowRoot.removeChild(node.shadowRoot.firstChild);\n          }\n        }\n      }\n      return node;\n    }\n    case NodeType.Text:\n      return doc.createTextNode(\n        n.isStyle && hackCss\n          ? adaptCssForReplay(n.textContent, cache)\n          : n.textContent,\n      );\n    case NodeType.CDATA:\n      return doc.createCDATASection(n.textContent);\n    case NodeType.Comment:\n      return doc.createComment(n.textContent);\n    default:\n      return null;\n  }\n}\n\nexport function buildNodeWithSN(\n  n: serializedNodeWithId,\n  options: {\n    doc: Document;\n    mirror: Mirror;\n    skipChild?: boolean;\n    hackCss: boolean;\n    /**\n     * This callback will be called for each of this nodes' `.childNodes` after they are appended to _this_ node.\n     * Caveat: This callback _doesn't_ get called when this node is appended to the DOM.\n     */\n    afterAppend?: (n: Node, id: number) => unknown;\n    cache: BuildCache;\n  },\n): Node | null {\n  const {\n    doc,\n    mirror,\n    skipChild = false,\n    hackCss = true,\n    afterAppend,\n    cache,\n  } = options;\n  /**\n   * Add a check to see if the node is already in the mirror. If it is, we can skip the whole process.\n   * This situation (duplicated nodes) can happen when recorder has some unfixed bugs and the same node is recorded twice. Or something goes wrong when saving or transferring event data.\n   * Duplicated node creation may cause unexpected errors in replayer. This check tries best effort to prevent the errors.\n   */\n  if (mirror.has(n.id)) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const nodeInMirror = mirror.getNode(n.id)!;\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const meta = mirror.getMeta(nodeInMirror)!;\n    // For safety concern, check if the node in mirror is the same as the node we are trying to build\n    if (isNodeMetaEqual(meta, n)) return mirror.getNode(n.id);\n  }\n  let node = buildNode(n, { doc, hackCss, cache });\n  if (!node) {\n    return null;\n  }\n  // If the snapshot is created by checkout, the rootId doesn't change but the iframe's document can be changed automatically when a new iframe element is created.\n  if (n.rootId && (mirror.getNode(n.rootId) as Document) !== doc) {\n    mirror.replace(n.rootId, doc);\n  }\n  // use target document as root document\n  if (n.type === NodeType.Document) {\n    // close before open to make sure document was closed\n    doc.close();\n    doc.open();\n    if (\n      n.compatMode === 'BackCompat' &&\n      n.childNodes &&\n      n.childNodes[0].type !== NodeType.DocumentType // there isn't one already defined\n    ) {\n      // Trigger compatMode in the iframe\n      // this is needed as document.createElement('iframe') otherwise inherits a CSS1Compat mode from the parent replayer environment\n      if (\n        n.childNodes[0].type === NodeType.Element &&\n        'xmlns' in n.childNodes[0].attributes &&\n        n.childNodes[0].attributes.xmlns === 'http://www.w3.org/1999/xhtml'\n      ) {\n        // might as well use an xhtml doctype if we've got an xhtml namespace\n        doc.write(\n          '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\">',\n        );\n      } else {\n        doc.write(\n          '<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\">',\n        );\n      }\n    }\n    node = doc;\n  }\n\n  mirror.add(node, n);\n\n  if (\n    (n.type === NodeType.Document || n.type === NodeType.Element) &&\n    !skipChild\n  ) {\n    for (const childN of n.childNodes) {\n      const childNode = buildNodeWithSN(childN, {\n        doc,\n        mirror,\n        skipChild: false,\n        hackCss,\n        afterAppend,\n        cache,\n      });\n      if (!childNode) {\n        console.warn('Failed to rebuild', childN);\n        continue;\n      }\n\n      if (childN.isShadow && isElement(node) && node.shadowRoot) {\n        node.shadowRoot.appendChild(childNode);\n      } else if (\n        n.type === NodeType.Document &&\n        childN.type == NodeType.Element\n      ) {\n        const htmlElement = childNode as HTMLElement;\n        let body: HTMLBodyElement | null = null;\n        htmlElement.childNodes.forEach((child) => {\n          if (child.nodeName === 'BODY') body = child as HTMLBodyElement;\n        });\n        if (body) {\n          // this branch solves a problem in Firefox where css transitions are incorrectly\n          // being applied upon rebuild.  Presumably FF doesn't finished parsing the styles\n          // in time, and applies e.g. a default margin:0 to elements which have a non-zero\n          // margin set in CSS, along with a transition on them\n          htmlElement.removeChild(body);\n          // append <head> and <style>s\n          node.appendChild(childNode);\n          // now append <body>\n          htmlElement.appendChild(body);\n        } else {\n          node.appendChild(childNode);\n        }\n      } else {\n        node.appendChild(childNode);\n      }\n      if (afterAppend) {\n        afterAppend(childNode, childN.id);\n      }\n    }\n  }\n\n  return node;\n}\n\nfunction visit(mirror: Mirror, onVisit: (node: Node) => void) {\n  function walk(node: Node) {\n    onVisit(node);\n  }\n\n  for (const id of mirror.getIds()) {\n    if (mirror.has(id)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      walk(mirror.getNode(id)!);\n    }\n  }\n}\n\nfunction handleScroll(node: Node, mirror: Mirror) {\n  const n = mirror.getMeta(node);\n  if (n?.type !== NodeType.Element) {\n    return;\n  }\n  const el = node as HTMLElement;\n  for (const name in n.attributes) {\n    if (\n      !(\n        Object.prototype.hasOwnProperty.call(n.attributes, name) &&\n        name.startsWith('rr_')\n      )\n    ) {\n      continue;\n    }\n    const value = n.attributes[name];\n    if (name === 'rr_scrollLeft') {\n      el.scrollLeft = value as number;\n    }\n    if (name === 'rr_scrollTop') {\n      el.scrollTop = value as number;\n    }\n  }\n}\n\nfunction rebuild(\n  n: serializedNodeWithId,\n  options: {\n    doc: Document;\n    onVisit?: (node: Node) => unknown;\n    hackCss?: boolean;\n    afterAppend?: (n: Node, id: number) => unknown;\n    cache: BuildCache;\n    mirror: Mirror;\n  },\n): Node | null {\n  const {\n    doc,\n    onVisit,\n    hackCss = true,\n    afterAppend,\n    cache,\n    mirror = new Mirror(),\n  } = options;\n  const node = buildNodeWithSN(n, {\n    doc,\n    mirror,\n    skipChild: false,\n    hackCss,\n    afterAppend,\n    cache,\n  });\n  visit(mirror, (visitedNode) => {\n    if (onVisit) {\n      onVisit(visitedNode);\n    }\n    handleScroll(visitedNode, mirror);\n  });\n  return node;\n}\n\nexport default rebuild;\n"],"names":["NodeType","rules","m"],"mappings":"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"}